// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openconfig_vlan.proto

#include "openconfig_vlan.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace opi_api {
namespace network {
namespace v1alpha1 {
constexpr SwitchedVlanSetting::SwitchedVlanSetting(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : trunk_vlans_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , vlan_interface_mode_(0)

  , native_vlan_(0u)
  , access_vlan_(0u){}
struct SwitchedVlanSettingDefaultTypeInternal {
  constexpr SwitchedVlanSettingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SwitchedVlanSettingDefaultTypeInternal() {}
  union {
    SwitchedVlanSetting _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SwitchedVlanSettingDefaultTypeInternal _SwitchedVlanSetting_default_instance_;
constexpr VlanSwitchedIf::VlanSwitchedIf(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr)
  , state_(nullptr){}
struct VlanSwitchedIfDefaultTypeInternal {
  constexpr VlanSwitchedIfDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanSwitchedIfDefaultTypeInternal() {}
  union {
    VlanSwitchedIf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanSwitchedIfDefaultTypeInternal _VlanSwitchedIf_default_instance_;
constexpr VlanIngressEgressSetting::VlanIngressEgressSetting(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vlanstackaction_(0)

  , vlan_id_(0u)
  , tpid_(0)
{}
struct VlanIngressEgressSettingDefaultTypeInternal {
  constexpr VlanIngressEgressSettingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIngressEgressSettingDefaultTypeInternal() {}
  union {
    VlanIngressEgressSetting _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIngressEgressSettingDefaultTypeInternal _VlanIngressEgressSetting_default_instance_;
constexpr VlanIf_VlanMatch_SingleTagged_SingleTagConfig::VlanIf_VlanMatch_SingleTagged_SingleTagConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vlan_id_(0u){}
struct VlanIf_VlanMatch_SingleTagged_SingleTagConfigDefaultTypeInternal {
  constexpr VlanIf_VlanMatch_SingleTagged_SingleTagConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanMatch_SingleTagged_SingleTagConfigDefaultTypeInternal() {}
  union {
    VlanIf_VlanMatch_SingleTagged_SingleTagConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanMatch_SingleTagged_SingleTagConfigDefaultTypeInternal _VlanIf_VlanMatch_SingleTagged_SingleTagConfig_default_instance_;
constexpr VlanIf_VlanMatch_SingleTagged_SingleTagState::VlanIf_VlanMatch_SingleTagged_SingleTagState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vlan_id_(0u){}
struct VlanIf_VlanMatch_SingleTagged_SingleTagStateDefaultTypeInternal {
  constexpr VlanIf_VlanMatch_SingleTagged_SingleTagStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanMatch_SingleTagged_SingleTagStateDefaultTypeInternal() {}
  union {
    VlanIf_VlanMatch_SingleTagged_SingleTagState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanMatch_SingleTagged_SingleTagStateDefaultTypeInternal _VlanIf_VlanMatch_SingleTagged_SingleTagState_default_instance_;
constexpr VlanIf_VlanMatch_SingleTagged::VlanIf_VlanMatch_SingleTagged(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr)
  , state_(nullptr){}
struct VlanIf_VlanMatch_SingleTaggedDefaultTypeInternal {
  constexpr VlanIf_VlanMatch_SingleTaggedDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanMatch_SingleTaggedDefaultTypeInternal() {}
  union {
    VlanIf_VlanMatch_SingleTagged _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanMatch_SingleTaggedDefaultTypeInternal _VlanIf_VlanMatch_SingleTagged_default_instance_;
constexpr VlanIf_VlanMatch_SingleTaggedList_TagListConfig::VlanIf_VlanMatch_SingleTaggedList_TagListConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vlan_id_()
  , _vlan_id_cached_byte_size_(0){}
struct VlanIf_VlanMatch_SingleTaggedList_TagListConfigDefaultTypeInternal {
  constexpr VlanIf_VlanMatch_SingleTaggedList_TagListConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanMatch_SingleTaggedList_TagListConfigDefaultTypeInternal() {}
  union {
    VlanIf_VlanMatch_SingleTaggedList_TagListConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanMatch_SingleTaggedList_TagListConfigDefaultTypeInternal _VlanIf_VlanMatch_SingleTaggedList_TagListConfig_default_instance_;
constexpr VlanIf_VlanMatch_SingleTaggedList_TagListStatus::VlanIf_VlanMatch_SingleTaggedList_TagListStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vlanid_()
  , _vlanid_cached_byte_size_(0){}
struct VlanIf_VlanMatch_SingleTaggedList_TagListStatusDefaultTypeInternal {
  constexpr VlanIf_VlanMatch_SingleTaggedList_TagListStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanMatch_SingleTaggedList_TagListStatusDefaultTypeInternal() {}
  union {
    VlanIf_VlanMatch_SingleTaggedList_TagListStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanMatch_SingleTaggedList_TagListStatusDefaultTypeInternal _VlanIf_VlanMatch_SingleTaggedList_TagListStatus_default_instance_;
constexpr VlanIf_VlanMatch_SingleTaggedList::VlanIf_VlanMatch_SingleTaggedList(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr)
  , status_(nullptr){}
struct VlanIf_VlanMatch_SingleTaggedListDefaultTypeInternal {
  constexpr VlanIf_VlanMatch_SingleTaggedListDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanMatch_SingleTaggedListDefaultTypeInternal() {}
  union {
    VlanIf_VlanMatch_SingleTaggedList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanMatch_SingleTaggedListDefaultTypeInternal _VlanIf_VlanMatch_SingleTaggedList_default_instance_;
constexpr VlanIf_VlanMatch::VlanIf_VlanMatch(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : singletagged_(nullptr)
  , singletaggedlist_(nullptr){}
struct VlanIf_VlanMatchDefaultTypeInternal {
  constexpr VlanIf_VlanMatchDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanMatchDefaultTypeInternal() {}
  union {
    VlanIf_VlanMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanMatchDefaultTypeInternal _VlanIf_VlanMatch_default_instance_;
constexpr VlanIf_VlanIngressMapping::VlanIf_VlanIngressMapping(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr)
  , state_(nullptr){}
struct VlanIf_VlanIngressMappingDefaultTypeInternal {
  constexpr VlanIf_VlanIngressMappingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanIngressMappingDefaultTypeInternal() {}
  union {
    VlanIf_VlanIngressMapping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanIngressMappingDefaultTypeInternal _VlanIf_VlanIngressMapping_default_instance_;
constexpr VlanIf_VlanEgressMapping::VlanIf_VlanEgressMapping(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr)
  , state_(nullptr){}
struct VlanIf_VlanEgressMappingDefaultTypeInternal {
  constexpr VlanIf_VlanEgressMappingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIf_VlanEgressMappingDefaultTypeInternal() {}
  union {
    VlanIf_VlanEgressMapping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIf_VlanEgressMappingDefaultTypeInternal _VlanIf_VlanEgressMapping_default_instance_;
constexpr VlanIf::VlanIf(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : match_(nullptr)
  , ingressmapping_(nullptr)
  , egressmapping_(nullptr){}
struct VlanIfDefaultTypeInternal {
  constexpr VlanIfDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VlanIfDefaultTypeInternal() {}
  union {
    VlanIf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VlanIfDefaultTypeInternal _VlanIf_default_instance_;
}  // namespace v1alpha1
}  // namespace network
}  // namespace opi_api
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_openconfig_5fvlan_2eproto[13];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_openconfig_5fvlan_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_openconfig_5fvlan_2eproto = nullptr;

const uint32_t TableStruct_openconfig_5fvlan_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::SwitchedVlanSetting, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::SwitchedVlanSetting, vlan_interface_mode_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::SwitchedVlanSetting, native_vlan_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::SwitchedVlanSetting, access_vlan_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::SwitchedVlanSetting, trunk_vlans_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanSwitchedIf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanSwitchedIf, config_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanSwitchedIf, state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIngressEgressSetting, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIngressEgressSetting, vlanstackaction_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIngressEgressSetting, vlan_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIngressEgressSetting, tpid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig, vlan_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState, vlan_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged, config_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged, state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig, vlan_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus, vlanid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList, config_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch, singletagged_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanMatch, singletaggedlist_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping, config_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping, state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping, config_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping, state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf, match_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf, ingressmapping_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::VlanIf, egressmapping_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::network::v1alpha1::SwitchedVlanSetting)},
  { 10, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanSwitchedIf)},
  { 18, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIngressEgressSetting)},
  { 27, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig)},
  { 34, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState)},
  { 41, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged)},
  { 49, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig)},
  { 56, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus)},
  { 63, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList)},
  { 71, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanMatch)},
  { 79, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping)},
  { 87, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping)},
  { 95, -1, -1, sizeof(::opi_api::network::v1alpha1::VlanIf)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_SwitchedVlanSetting_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanSwitchedIf_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIngressEgressSetting_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTagged_SingleTagConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTagged_SingleTagState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTagged_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTaggedList_TagListConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTaggedList_TagListStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTaggedList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanMatch_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanIngressMapping_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_VlanEgressMapping_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_VlanIf_default_instance_),
};

const char descriptor_table_protodef_openconfig_5fvlan_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025openconfig_vlan.proto\022\030opi_api.network"
  ".v1alpha1\"\227\001\n\023SwitchedVlanSetting\022A\n\023vla"
  "n_interface_mode\030\001 \001(\0162$.opi_api.network"
  ".v1alpha1.VlanIfMode\022\023\n\013native_vlan\030\002 \001("
  "\r\022\023\n\013access_vlan\030\003 \001(\r\022\023\n\013trunk_vlans\030\004 "
  "\001(\t\"\215\001\n\016VlanSwitchedIf\022=\n\006config\030\001 \001(\0132-"
  ".opi_api.network.v1alpha1.SwitchedVlanSe"
  "tting\022<\n\005state\030\002 \001(\0132-.opi_api.network.v"
  "1alpha1.SwitchedVlanSetting\"\242\001\n\030VlanIngr"
  "essEgressSetting\022B\n\017vlanstackaction\030\001 \001("
  "\0162).opi_api.network.v1alpha1.VlanStackAc"
  "tion\022\017\n\007vlan_id\030\002 \001(\r\0221\n\004tpid\030\003 \001(\0162#.op"
  "i_api.network.v1alpha1.TpidTypes\"\340\t\n\006Vla"
  "nIf\0229\n\005match\030\001 \001(\0132*.opi_api.network.v1a"
  "lpha1.VlanIf.VlanMatch\022K\n\016ingressmapping"
  "\030\002 \001(\01323.opi_api.network.v1alpha1.VlanIf"
  ".VlanIngressMapping\022I\n\regressmapping\030\003 \001"
  "(\01322.opi_api.network.v1alpha1.VlanIf.Vla"
  "nEgressMapping\032\307\005\n\tVlanMatch\022M\n\014singleta"
  "gged\030\001 \001(\01327.opi_api.network.v1alpha1.Vl"
  "anIf.VlanMatch.SingleTagged\022U\n\020singletag"
  "gedlist\030\002 \001(\0132;.opi_api.network.v1alpha1"
  ".VlanIf.VlanMatch.SingleTaggedList\032\205\002\n\014S"
  "ingleTagged\022W\n\006config\030\001 \001(\0132G.opi_api.ne"
  "twork.v1alpha1.VlanIf.VlanMatch.SingleTa"
  "gged.SingleTagConfig\022U\n\005state\030\002 \001(\0132F.op"
  "i_api.network.v1alpha1.VlanIf.VlanMatch."
  "SingleTagged.SingleTagState\032\"\n\017SingleTag"
  "Config\022\017\n\007vlan_id\030\001 \001(\r\032!\n\016SingleTagStat"
  "e\022\017\n\007vlan_id\030\001 \001(\r\032\213\002\n\020SingleTaggedList\022"
  "Y\n\006config\030\001 \001(\0132I.opi_api.network.v1alph"
  "a1.VlanIf.VlanMatch.SingleTaggedList.Tag"
  "ListConfig\022Y\n\006status\030\002 \001(\0132I.opi_api.net"
  "work.v1alpha1.VlanIf.VlanMatch.SingleTag"
  "gedList.TagListStatus\032 \n\rTagListConfig\022\017"
  "\n\007vlan_id\030\001 \003(\r\032\037\n\rTagListStatus\022\016\n\006vlan"
  "id\030\001 \003(\r\032\233\001\n\022VlanIngressMapping\022B\n\006confi"
  "g\030\001 \001(\01322.opi_api.network.v1alpha1.VlanI"
  "ngressEgressSetting\022A\n\005state\030\002 \001(\01322.opi"
  "_api.network.v1alpha1.VlanIngressEgressS"
  "etting\032\232\001\n\021VlanEgressMapping\022B\n\006config\030\001"
  " \001(\01322.opi_api.network.v1alpha1.VlanIngr"
  "essEgressSetting\022A\n\005state\030\002 \001(\01322.opi_ap"
  "i.network.v1alpha1.VlanIngressEgressSett"
  "ing*\227\001\n\tTpidTypes\022\032\n\026TPID_TYPES_UNSPECIF"
  "IED\020\000\022\025\n\021TPID_TYPES_0X8100\020\001\022\025\n\021TPID_TYP"
  "ES_0X88A8\020\002\022\025\n\021TPID_TYPES_0X9100\020\003\022\025\n\021TP"
  "ID_TYPES_0X9200\020\004\022\022\n\016TPID_TYPES_ANY\020\005*\207\001"
  "\n\017VlanStackAction\022!\n\035VLAN_STACK_ACTION_U"
  "NSPECIFIED\020\000\022\032\n\026VLAN_STACK_ACTION_PUSH\020\001"
  "\022\031\n\025VLAN_STACK_ACTION_POP\020\002\022\032\n\026VLAN_STAC"
  "K_ACTION_SWAP\020\003*[\n\nVlanIfMode\022\034\n\030VLAN_IF"
  "_MODE_UNSPECIFIED\020\000\022\027\n\023VLAN_IF_MODE_ACCE"
  "SS\020\001\022\026\n\022VLAN_IF_MODE_TRUNK\020\002Bu\n\030opi_api."
  "network.v1alpha1B\023OpenconfigVlanProtoP\001Z"
  "Bgithub.com/opiproject/opi-api/network/o"
  "pinetcommon/v1alpha1/gen/gob\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_openconfig_5fvlan_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openconfig_5fvlan_2eproto = {
  false, false, 2275, descriptor_table_protodef_openconfig_5fvlan_2eproto, "openconfig_vlan.proto", 
  &descriptor_table_openconfig_5fvlan_2eproto_once, nullptr, 0, 13,
  schemas, file_default_instances, TableStruct_openconfig_5fvlan_2eproto::offsets,
  file_level_metadata_openconfig_5fvlan_2eproto, file_level_enum_descriptors_openconfig_5fvlan_2eproto, file_level_service_descriptors_openconfig_5fvlan_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_openconfig_5fvlan_2eproto_getter() {
  return &descriptor_table_openconfig_5fvlan_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_openconfig_5fvlan_2eproto(&descriptor_table_openconfig_5fvlan_2eproto);
namespace opi_api {
namespace network {
namespace v1alpha1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TpidTypes_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_openconfig_5fvlan_2eproto);
  return file_level_enum_descriptors_openconfig_5fvlan_2eproto[0];
}
bool TpidTypes_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VlanStackAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_openconfig_5fvlan_2eproto);
  return file_level_enum_descriptors_openconfig_5fvlan_2eproto[1];
}
bool VlanStackAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VlanIfMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_openconfig_5fvlan_2eproto);
  return file_level_enum_descriptors_openconfig_5fvlan_2eproto[2];
}
bool VlanIfMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class SwitchedVlanSetting::_Internal {
 public:
};

SwitchedVlanSetting::SwitchedVlanSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.SwitchedVlanSetting)
}
SwitchedVlanSetting::SwitchedVlanSetting(const SwitchedVlanSetting& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  trunk_vlans_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trunk_vlans_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trunk_vlans().empty()) {
    trunk_vlans_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_trunk_vlans(), 
      GetArenaForAllocation());
  }
  ::memcpy(&vlan_interface_mode_, &from.vlan_interface_mode_,
    static_cast<size_t>(reinterpret_cast<char*>(&access_vlan_) -
    reinterpret_cast<char*>(&vlan_interface_mode_)) + sizeof(access_vlan_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.SwitchedVlanSetting)
}

inline void SwitchedVlanSetting::SharedCtor() {
trunk_vlans_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trunk_vlans_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vlan_interface_mode_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&access_vlan_) -
    reinterpret_cast<char*>(&vlan_interface_mode_)) + sizeof(access_vlan_));
}

SwitchedVlanSetting::~SwitchedVlanSetting() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.SwitchedVlanSetting)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SwitchedVlanSetting::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  trunk_vlans_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SwitchedVlanSetting::ArenaDtor(void* object) {
  SwitchedVlanSetting* _this = reinterpret_cast< SwitchedVlanSetting* >(object);
  (void)_this;
}
void SwitchedVlanSetting::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SwitchedVlanSetting::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SwitchedVlanSetting::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.SwitchedVlanSetting)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trunk_vlans_.ClearToEmpty();
  ::memset(&vlan_interface_mode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&access_vlan_) -
      reinterpret_cast<char*>(&vlan_interface_mode_)) + sizeof(access_vlan_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SwitchedVlanSetting::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.VlanIfMode vlan_interface_mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_vlan_interface_mode(static_cast<::opi_api::network::v1alpha1::VlanIfMode>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 native_vlan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          native_vlan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 access_vlan = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          access_vlan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string trunk_vlans = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_trunk_vlans();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.network.v1alpha1.SwitchedVlanSetting.trunk_vlans"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SwitchedVlanSetting::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.SwitchedVlanSetting)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIfMode vlan_interface_mode = 1;
  if (this->_internal_vlan_interface_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_vlan_interface_mode(), target);
  }

  // uint32 native_vlan = 2;
  if (this->_internal_native_vlan() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_native_vlan(), target);
  }

  // uint32 access_vlan = 3;
  if (this->_internal_access_vlan() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_access_vlan(), target);
  }

  // string trunk_vlans = 4;
  if (!this->_internal_trunk_vlans().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_trunk_vlans().data(), static_cast<int>(this->_internal_trunk_vlans().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.v1alpha1.SwitchedVlanSetting.trunk_vlans");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_trunk_vlans(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.SwitchedVlanSetting)
  return target;
}

size_t SwitchedVlanSetting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.SwitchedVlanSetting)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string trunk_vlans = 4;
  if (!this->_internal_trunk_vlans().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_trunk_vlans());
  }

  // .opi_api.network.v1alpha1.VlanIfMode vlan_interface_mode = 1;
  if (this->_internal_vlan_interface_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_vlan_interface_mode());
  }

  // uint32 native_vlan = 2;
  if (this->_internal_native_vlan() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_native_vlan());
  }

  // uint32 access_vlan = 3;
  if (this->_internal_access_vlan() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_access_vlan());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SwitchedVlanSetting::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SwitchedVlanSetting::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SwitchedVlanSetting::GetClassData() const { return &_class_data_; }

void SwitchedVlanSetting::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SwitchedVlanSetting *>(to)->MergeFrom(
      static_cast<const SwitchedVlanSetting &>(from));
}


void SwitchedVlanSetting::MergeFrom(const SwitchedVlanSetting& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.SwitchedVlanSetting)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_trunk_vlans().empty()) {
    _internal_set_trunk_vlans(from._internal_trunk_vlans());
  }
  if (from._internal_vlan_interface_mode() != 0) {
    _internal_set_vlan_interface_mode(from._internal_vlan_interface_mode());
  }
  if (from._internal_native_vlan() != 0) {
    _internal_set_native_vlan(from._internal_native_vlan());
  }
  if (from._internal_access_vlan() != 0) {
    _internal_set_access_vlan(from._internal_access_vlan());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SwitchedVlanSetting::CopyFrom(const SwitchedVlanSetting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.SwitchedVlanSetting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwitchedVlanSetting::IsInitialized() const {
  return true;
}

void SwitchedVlanSetting::InternalSwap(SwitchedVlanSetting* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &trunk_vlans_, lhs_arena,
      &other->trunk_vlans_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SwitchedVlanSetting, access_vlan_)
      + sizeof(SwitchedVlanSetting::access_vlan_)
      - PROTOBUF_FIELD_OFFSET(SwitchedVlanSetting, vlan_interface_mode_)>(
          reinterpret_cast<char*>(&vlan_interface_mode_),
          reinterpret_cast<char*>(&other->vlan_interface_mode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SwitchedVlanSetting::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[0]);
}

// ===================================================================

class VlanSwitchedIf::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::SwitchedVlanSetting& config(const VlanSwitchedIf* msg);
  static const ::opi_api::network::v1alpha1::SwitchedVlanSetting& state(const VlanSwitchedIf* msg);
};

const ::opi_api::network::v1alpha1::SwitchedVlanSetting&
VlanSwitchedIf::_Internal::config(const VlanSwitchedIf* msg) {
  return *msg->config_;
}
const ::opi_api::network::v1alpha1::SwitchedVlanSetting&
VlanSwitchedIf::_Internal::state(const VlanSwitchedIf* msg) {
  return *msg->state_;
}
VlanSwitchedIf::VlanSwitchedIf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanSwitchedIf)
}
VlanSwitchedIf::VlanSwitchedIf(const VlanSwitchedIf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::opi_api::network::v1alpha1::SwitchedVlanSetting(*from.config_);
  } else {
    config_ = nullptr;
  }
  if (from._internal_has_state()) {
    state_ = new ::opi_api::network::v1alpha1::SwitchedVlanSetting(*from.state_);
  } else {
    state_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanSwitchedIf)
}

inline void VlanSwitchedIf::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&config_)) + sizeof(state_));
}

VlanSwitchedIf::~VlanSwitchedIf() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanSwitchedIf)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanSwitchedIf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
  if (this != internal_default_instance()) delete state_;
}

void VlanSwitchedIf::ArenaDtor(void* object) {
  VlanSwitchedIf* _this = reinterpret_cast< VlanSwitchedIf* >(object);
  (void)_this;
}
void VlanSwitchedIf::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanSwitchedIf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanSwitchedIf::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanSwitchedIf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanSwitchedIf::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.SwitchedVlanSetting config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.SwitchedVlanSetting state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanSwitchedIf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanSwitchedIf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.SwitchedVlanSetting config = 1;
  if (this->_internal_has_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::config(this), target, stream);
  }

  // .opi_api.network.v1alpha1.SwitchedVlanSetting state = 2;
  if (this->_internal_has_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::state(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanSwitchedIf)
  return target;
}

size_t VlanSwitchedIf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanSwitchedIf)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.SwitchedVlanSetting config = 1;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }

  // .opi_api.network.v1alpha1.SwitchedVlanSetting state = 2;
  if (this->_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanSwitchedIf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanSwitchedIf::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanSwitchedIf::GetClassData() const { return &_class_data_; }

void VlanSwitchedIf::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanSwitchedIf *>(to)->MergeFrom(
      static_cast<const VlanSwitchedIf &>(from));
}


void VlanSwitchedIf::MergeFrom(const VlanSwitchedIf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanSwitchedIf)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _internal_mutable_config()->::opi_api::network::v1alpha1::SwitchedVlanSetting::MergeFrom(from._internal_config());
  }
  if (from._internal_has_state()) {
    _internal_mutable_state()->::opi_api::network::v1alpha1::SwitchedVlanSetting::MergeFrom(from._internal_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanSwitchedIf::CopyFrom(const VlanSwitchedIf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanSwitchedIf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanSwitchedIf::IsInitialized() const {
  return true;
}

void VlanSwitchedIf::InternalSwap(VlanSwitchedIf* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VlanSwitchedIf, state_)
      + sizeof(VlanSwitchedIf::state_)
      - PROTOBUF_FIELD_OFFSET(VlanSwitchedIf, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanSwitchedIf::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[1]);
}

// ===================================================================

class VlanIngressEgressSetting::_Internal {
 public:
};

VlanIngressEgressSetting::VlanIngressEgressSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIngressEgressSetting)
}
VlanIngressEgressSetting::VlanIngressEgressSetting(const VlanIngressEgressSetting& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&vlanstackaction_, &from.vlanstackaction_,
    static_cast<size_t>(reinterpret_cast<char*>(&tpid_) -
    reinterpret_cast<char*>(&vlanstackaction_)) + sizeof(tpid_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIngressEgressSetting)
}

inline void VlanIngressEgressSetting::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vlanstackaction_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tpid_) -
    reinterpret_cast<char*>(&vlanstackaction_)) + sizeof(tpid_));
}

VlanIngressEgressSetting::~VlanIngressEgressSetting() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIngressEgressSetting)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIngressEgressSetting::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VlanIngressEgressSetting::ArenaDtor(void* object) {
  VlanIngressEgressSetting* _this = reinterpret_cast< VlanIngressEgressSetting* >(object);
  (void)_this;
}
void VlanIngressEgressSetting::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIngressEgressSetting::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIngressEgressSetting::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIngressEgressSetting)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&vlanstackaction_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tpid_) -
      reinterpret_cast<char*>(&vlanstackaction_)) + sizeof(tpid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIngressEgressSetting::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.VlanStackAction vlanstackaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_vlanstackaction(static_cast<::opi_api::network::v1alpha1::VlanStackAction>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 vlan_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          vlan_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.TpidTypes tpid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_tpid(static_cast<::opi_api::network::v1alpha1::TpidTypes>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIngressEgressSetting::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIngressEgressSetting)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanStackAction vlanstackaction = 1;
  if (this->_internal_vlanstackaction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_vlanstackaction(), target);
  }

  // uint32 vlan_id = 2;
  if (this->_internal_vlan_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_vlan_id(), target);
  }

  // .opi_api.network.v1alpha1.TpidTypes tpid = 3;
  if (this->_internal_tpid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_tpid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIngressEgressSetting)
  return target;
}

size_t VlanIngressEgressSetting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIngressEgressSetting)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanStackAction vlanstackaction = 1;
  if (this->_internal_vlanstackaction() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_vlanstackaction());
  }

  // uint32 vlan_id = 2;
  if (this->_internal_vlan_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_vlan_id());
  }

  // .opi_api.network.v1alpha1.TpidTypes tpid = 3;
  if (this->_internal_tpid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_tpid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIngressEgressSetting::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIngressEgressSetting::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIngressEgressSetting::GetClassData() const { return &_class_data_; }

void VlanIngressEgressSetting::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIngressEgressSetting *>(to)->MergeFrom(
      static_cast<const VlanIngressEgressSetting &>(from));
}


void VlanIngressEgressSetting::MergeFrom(const VlanIngressEgressSetting& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIngressEgressSetting)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_vlanstackaction() != 0) {
    _internal_set_vlanstackaction(from._internal_vlanstackaction());
  }
  if (from._internal_vlan_id() != 0) {
    _internal_set_vlan_id(from._internal_vlan_id());
  }
  if (from._internal_tpid() != 0) {
    _internal_set_tpid(from._internal_tpid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIngressEgressSetting::CopyFrom(const VlanIngressEgressSetting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIngressEgressSetting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIngressEgressSetting::IsInitialized() const {
  return true;
}

void VlanIngressEgressSetting::InternalSwap(VlanIngressEgressSetting* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VlanIngressEgressSetting, tpid_)
      + sizeof(VlanIngressEgressSetting::tpid_)
      - PROTOBUF_FIELD_OFFSET(VlanIngressEgressSetting, vlanstackaction_)>(
          reinterpret_cast<char*>(&vlanstackaction_),
          reinterpret_cast<char*>(&other->vlanstackaction_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIngressEgressSetting::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[2]);
}

// ===================================================================

class VlanIf_VlanMatch_SingleTagged_SingleTagConfig::_Internal {
 public:
};

VlanIf_VlanMatch_SingleTagged_SingleTagConfig::VlanIf_VlanMatch_SingleTagged_SingleTagConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
}
VlanIf_VlanMatch_SingleTagged_SingleTagConfig::VlanIf_VlanMatch_SingleTagged_SingleTagConfig(const VlanIf_VlanMatch_SingleTagged_SingleTagConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  vlan_id_ = from.vlan_id_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
}

inline void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::SharedCtor() {
vlan_id_ = 0u;
}

VlanIf_VlanMatch_SingleTagged_SingleTagConfig::~VlanIf_VlanMatch_SingleTagged_SingleTagConfig() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::ArenaDtor(void* object) {
  VlanIf_VlanMatch_SingleTagged_SingleTagConfig* _this = reinterpret_cast< VlanIf_VlanMatch_SingleTagged_SingleTagConfig* >(object);
  (void)_this;
}
void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vlan_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanMatch_SingleTagged_SingleTagConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 vlan_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          vlan_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanMatch_SingleTagged_SingleTagConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 vlan_id = 1;
  if (this->_internal_vlan_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vlan_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
  return target;
}

size_t VlanIf_VlanMatch_SingleTagged_SingleTagConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 vlan_id = 1;
  if (this->_internal_vlan_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_vlan_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanMatch_SingleTagged_SingleTagConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanMatch_SingleTagged_SingleTagConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanMatch_SingleTagged_SingleTagConfig::GetClassData() const { return &_class_data_; }

void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanMatch_SingleTagged_SingleTagConfig *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanMatch_SingleTagged_SingleTagConfig &>(from));
}


void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::MergeFrom(const VlanIf_VlanMatch_SingleTagged_SingleTagConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_vlan_id() != 0) {
    _internal_set_vlan_id(from._internal_vlan_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::CopyFrom(const VlanIf_VlanMatch_SingleTagged_SingleTagConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanMatch_SingleTagged_SingleTagConfig::IsInitialized() const {
  return true;
}

void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::InternalSwap(VlanIf_VlanMatch_SingleTagged_SingleTagConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(vlan_id_, other->vlan_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanMatch_SingleTagged_SingleTagConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[3]);
}

// ===================================================================

class VlanIf_VlanMatch_SingleTagged_SingleTagState::_Internal {
 public:
};

VlanIf_VlanMatch_SingleTagged_SingleTagState::VlanIf_VlanMatch_SingleTagged_SingleTagState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
}
VlanIf_VlanMatch_SingleTagged_SingleTagState::VlanIf_VlanMatch_SingleTagged_SingleTagState(const VlanIf_VlanMatch_SingleTagged_SingleTagState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  vlan_id_ = from.vlan_id_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
}

inline void VlanIf_VlanMatch_SingleTagged_SingleTagState::SharedCtor() {
vlan_id_ = 0u;
}

VlanIf_VlanMatch_SingleTagged_SingleTagState::~VlanIf_VlanMatch_SingleTagged_SingleTagState() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanMatch_SingleTagged_SingleTagState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VlanIf_VlanMatch_SingleTagged_SingleTagState::ArenaDtor(void* object) {
  VlanIf_VlanMatch_SingleTagged_SingleTagState* _this = reinterpret_cast< VlanIf_VlanMatch_SingleTagged_SingleTagState* >(object);
  (void)_this;
}
void VlanIf_VlanMatch_SingleTagged_SingleTagState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanMatch_SingleTagged_SingleTagState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanMatch_SingleTagged_SingleTagState::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vlan_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanMatch_SingleTagged_SingleTagState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 vlan_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          vlan_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanMatch_SingleTagged_SingleTagState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 vlan_id = 1;
  if (this->_internal_vlan_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vlan_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
  return target;
}

size_t VlanIf_VlanMatch_SingleTagged_SingleTagState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 vlan_id = 1;
  if (this->_internal_vlan_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_vlan_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanMatch_SingleTagged_SingleTagState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanMatch_SingleTagged_SingleTagState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanMatch_SingleTagged_SingleTagState::GetClassData() const { return &_class_data_; }

void VlanIf_VlanMatch_SingleTagged_SingleTagState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanMatch_SingleTagged_SingleTagState *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanMatch_SingleTagged_SingleTagState &>(from));
}


void VlanIf_VlanMatch_SingleTagged_SingleTagState::MergeFrom(const VlanIf_VlanMatch_SingleTagged_SingleTagState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_vlan_id() != 0) {
    _internal_set_vlan_id(from._internal_vlan_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanMatch_SingleTagged_SingleTagState::CopyFrom(const VlanIf_VlanMatch_SingleTagged_SingleTagState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanMatch_SingleTagged_SingleTagState::IsInitialized() const {
  return true;
}

void VlanIf_VlanMatch_SingleTagged_SingleTagState::InternalSwap(VlanIf_VlanMatch_SingleTagged_SingleTagState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(vlan_id_, other->vlan_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanMatch_SingleTagged_SingleTagState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[4]);
}

// ===================================================================

class VlanIf_VlanMatch_SingleTagged::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig& config(const VlanIf_VlanMatch_SingleTagged* msg);
  static const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState& state(const VlanIf_VlanMatch_SingleTagged* msg);
};

const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig&
VlanIf_VlanMatch_SingleTagged::_Internal::config(const VlanIf_VlanMatch_SingleTagged* msg) {
  return *msg->config_;
}
const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState&
VlanIf_VlanMatch_SingleTagged::_Internal::state(const VlanIf_VlanMatch_SingleTagged* msg) {
  return *msg->state_;
}
VlanIf_VlanMatch_SingleTagged::VlanIf_VlanMatch_SingleTagged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
}
VlanIf_VlanMatch_SingleTagged::VlanIf_VlanMatch_SingleTagged(const VlanIf_VlanMatch_SingleTagged& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig(*from.config_);
  } else {
    config_ = nullptr;
  }
  if (from._internal_has_state()) {
    state_ = new ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState(*from.state_);
  } else {
    state_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
}

inline void VlanIf_VlanMatch_SingleTagged::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&config_)) + sizeof(state_));
}

VlanIf_VlanMatch_SingleTagged::~VlanIf_VlanMatch_SingleTagged() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanMatch_SingleTagged::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
  if (this != internal_default_instance()) delete state_;
}

void VlanIf_VlanMatch_SingleTagged::ArenaDtor(void* object) {
  VlanIf_VlanMatch_SingleTagged* _this = reinterpret_cast< VlanIf_VlanMatch_SingleTagged* >(object);
  (void)_this;
}
void VlanIf_VlanMatch_SingleTagged::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanMatch_SingleTagged::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanMatch_SingleTagged::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanMatch_SingleTagged::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanMatch_SingleTagged::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig config = 1;
  if (this->_internal_has_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::config(this), target, stream);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState state = 2;
  if (this->_internal_has_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::state(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
  return target;
}

size_t VlanIf_VlanMatch_SingleTagged::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig config = 1;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState state = 2;
  if (this->_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanMatch_SingleTagged::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanMatch_SingleTagged::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanMatch_SingleTagged::GetClassData() const { return &_class_data_; }

void VlanIf_VlanMatch_SingleTagged::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanMatch_SingleTagged *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanMatch_SingleTagged &>(from));
}


void VlanIf_VlanMatch_SingleTagged::MergeFrom(const VlanIf_VlanMatch_SingleTagged& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _internal_mutable_config()->::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig::MergeFrom(from._internal_config());
  }
  if (from._internal_has_state()) {
    _internal_mutable_state()->::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState::MergeFrom(from._internal_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanMatch_SingleTagged::CopyFrom(const VlanIf_VlanMatch_SingleTagged& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanMatch_SingleTagged::IsInitialized() const {
  return true;
}

void VlanIf_VlanMatch_SingleTagged::InternalSwap(VlanIf_VlanMatch_SingleTagged* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VlanIf_VlanMatch_SingleTagged, state_)
      + sizeof(VlanIf_VlanMatch_SingleTagged::state_)
      - PROTOBUF_FIELD_OFFSET(VlanIf_VlanMatch_SingleTagged, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanMatch_SingleTagged::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[5]);
}

// ===================================================================

class VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_Internal {
 public:
};

VlanIf_VlanMatch_SingleTaggedList_TagListConfig::VlanIf_VlanMatch_SingleTaggedList_TagListConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  vlan_id_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
}
VlanIf_VlanMatch_SingleTaggedList_TagListConfig::VlanIf_VlanMatch_SingleTaggedList_TagListConfig(const VlanIf_VlanMatch_SingleTaggedList_TagListConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      vlan_id_(from.vlan_id_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
}

inline void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::SharedCtor() {
}

VlanIf_VlanMatch_SingleTaggedList_TagListConfig::~VlanIf_VlanMatch_SingleTaggedList_TagListConfig() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::ArenaDtor(void* object) {
  VlanIf_VlanMatch_SingleTaggedList_TagListConfig* _this = reinterpret_cast< VlanIf_VlanMatch_SingleTaggedList_TagListConfig* >(object);
  (void)_this;
}
void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vlan_id_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 vlan_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_vlan_id(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vlan_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 vlan_id = 1;
  {
    int byte_size = _vlan_id_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_vlan_id(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
  return target;
}

size_t VlanIf_VlanMatch_SingleTaggedList_TagListConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 vlan_id = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->vlan_id_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _vlan_id_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanMatch_SingleTaggedList_TagListConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanMatch_SingleTaggedList_TagListConfig::GetClassData() const { return &_class_data_; }

void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanMatch_SingleTaggedList_TagListConfig *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanMatch_SingleTaggedList_TagListConfig &>(from));
}


void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::MergeFrom(const VlanIf_VlanMatch_SingleTaggedList_TagListConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vlan_id_.MergeFrom(from.vlan_id_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::CopyFrom(const VlanIf_VlanMatch_SingleTaggedList_TagListConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanMatch_SingleTaggedList_TagListConfig::IsInitialized() const {
  return true;
}

void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::InternalSwap(VlanIf_VlanMatch_SingleTaggedList_TagListConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vlan_id_.InternalSwap(&other->vlan_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanMatch_SingleTaggedList_TagListConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[6]);
}

// ===================================================================

class VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_Internal {
 public:
};

VlanIf_VlanMatch_SingleTaggedList_TagListStatus::VlanIf_VlanMatch_SingleTaggedList_TagListStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  vlanid_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
}
VlanIf_VlanMatch_SingleTaggedList_TagListStatus::VlanIf_VlanMatch_SingleTaggedList_TagListStatus(const VlanIf_VlanMatch_SingleTaggedList_TagListStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      vlanid_(from.vlanid_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
}

inline void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::SharedCtor() {
}

VlanIf_VlanMatch_SingleTaggedList_TagListStatus::~VlanIf_VlanMatch_SingleTaggedList_TagListStatus() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::ArenaDtor(void* object) {
  VlanIf_VlanMatch_SingleTaggedList_TagListStatus* _this = reinterpret_cast< VlanIf_VlanMatch_SingleTaggedList_TagListStatus* >(object);
  (void)_this;
}
void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vlanid_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 vlanid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_vlanid(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vlanid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 vlanid = 1;
  {
    int byte_size = _vlanid_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_vlanid(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
  return target;
}

size_t VlanIf_VlanMatch_SingleTaggedList_TagListStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 vlanid = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->vlanid_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _vlanid_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanMatch_SingleTaggedList_TagListStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanMatch_SingleTaggedList_TagListStatus::GetClassData() const { return &_class_data_; }

void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanMatch_SingleTaggedList_TagListStatus *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanMatch_SingleTaggedList_TagListStatus &>(from));
}


void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::MergeFrom(const VlanIf_VlanMatch_SingleTaggedList_TagListStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vlanid_.MergeFrom(from.vlanid_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::CopyFrom(const VlanIf_VlanMatch_SingleTaggedList_TagListStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanMatch_SingleTaggedList_TagListStatus::IsInitialized() const {
  return true;
}

void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::InternalSwap(VlanIf_VlanMatch_SingleTaggedList_TagListStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vlanid_.InternalSwap(&other->vlanid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanMatch_SingleTaggedList_TagListStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[7]);
}

// ===================================================================

class VlanIf_VlanMatch_SingleTaggedList::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig& config(const VlanIf_VlanMatch_SingleTaggedList* msg);
  static const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus& status(const VlanIf_VlanMatch_SingleTaggedList* msg);
};

const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig&
VlanIf_VlanMatch_SingleTaggedList::_Internal::config(const VlanIf_VlanMatch_SingleTaggedList* msg) {
  return *msg->config_;
}
const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus&
VlanIf_VlanMatch_SingleTaggedList::_Internal::status(const VlanIf_VlanMatch_SingleTaggedList* msg) {
  return *msg->status_;
}
VlanIf_VlanMatch_SingleTaggedList::VlanIf_VlanMatch_SingleTaggedList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
}
VlanIf_VlanMatch_SingleTaggedList::VlanIf_VlanMatch_SingleTaggedList(const VlanIf_VlanMatch_SingleTaggedList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig(*from.config_);
  } else {
    config_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
}

inline void VlanIf_VlanMatch_SingleTaggedList::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&config_)) + sizeof(status_));
}

VlanIf_VlanMatch_SingleTaggedList::~VlanIf_VlanMatch_SingleTaggedList() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanMatch_SingleTaggedList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
  if (this != internal_default_instance()) delete status_;
}

void VlanIf_VlanMatch_SingleTaggedList::ArenaDtor(void* object) {
  VlanIf_VlanMatch_SingleTaggedList* _this = reinterpret_cast< VlanIf_VlanMatch_SingleTaggedList* >(object);
  (void)_this;
}
void VlanIf_VlanMatch_SingleTaggedList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanMatch_SingleTaggedList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanMatch_SingleTaggedList::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanMatch_SingleTaggedList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanMatch_SingleTaggedList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig config = 1;
  if (this->_internal_has_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::config(this), target, stream);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus status = 2;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
  return target;
}

size_t VlanIf_VlanMatch_SingleTaggedList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig config = 1;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus status = 2;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanMatch_SingleTaggedList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanMatch_SingleTaggedList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanMatch_SingleTaggedList::GetClassData() const { return &_class_data_; }

void VlanIf_VlanMatch_SingleTaggedList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanMatch_SingleTaggedList *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanMatch_SingleTaggedList &>(from));
}


void VlanIf_VlanMatch_SingleTaggedList::MergeFrom(const VlanIf_VlanMatch_SingleTaggedList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _internal_mutable_config()->::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig::MergeFrom(from._internal_config());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanMatch_SingleTaggedList::CopyFrom(const VlanIf_VlanMatch_SingleTaggedList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanMatch_SingleTaggedList::IsInitialized() const {
  return true;
}

void VlanIf_VlanMatch_SingleTaggedList::InternalSwap(VlanIf_VlanMatch_SingleTaggedList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VlanIf_VlanMatch_SingleTaggedList, status_)
      + sizeof(VlanIf_VlanMatch_SingleTaggedList::status_)
      - PROTOBUF_FIELD_OFFSET(VlanIf_VlanMatch_SingleTaggedList, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanMatch_SingleTaggedList::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[8]);
}

// ===================================================================

class VlanIf_VlanMatch::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged& singletagged(const VlanIf_VlanMatch* msg);
  static const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList& singletaggedlist(const VlanIf_VlanMatch* msg);
};

const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged&
VlanIf_VlanMatch::_Internal::singletagged(const VlanIf_VlanMatch* msg) {
  return *msg->singletagged_;
}
const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList&
VlanIf_VlanMatch::_Internal::singletaggedlist(const VlanIf_VlanMatch* msg) {
  return *msg->singletaggedlist_;
}
VlanIf_VlanMatch::VlanIf_VlanMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch)
}
VlanIf_VlanMatch::VlanIf_VlanMatch(const VlanIf_VlanMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_singletagged()) {
    singletagged_ = new ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged(*from.singletagged_);
  } else {
    singletagged_ = nullptr;
  }
  if (from._internal_has_singletaggedlist()) {
    singletaggedlist_ = new ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList(*from.singletaggedlist_);
  } else {
    singletaggedlist_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanMatch)
}

inline void VlanIf_VlanMatch::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&singletagged_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&singletaggedlist_) -
    reinterpret_cast<char*>(&singletagged_)) + sizeof(singletaggedlist_));
}

VlanIf_VlanMatch::~VlanIf_VlanMatch() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanMatch)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete singletagged_;
  if (this != internal_default_instance()) delete singletaggedlist_;
}

void VlanIf_VlanMatch::ArenaDtor(void* object) {
  VlanIf_VlanMatch* _this = reinterpret_cast< VlanIf_VlanMatch* >(object);
  (void)_this;
}
void VlanIf_VlanMatch::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanMatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && singletagged_ != nullptr) {
    delete singletagged_;
  }
  singletagged_ = nullptr;
  if (GetArenaForAllocation() == nullptr && singletaggedlist_ != nullptr) {
    delete singletaggedlist_;
  }
  singletaggedlist_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanMatch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged singletagged = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_singletagged(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList singletaggedlist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_singletaggedlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged singletagged = 1;
  if (this->_internal_has_singletagged()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::singletagged(this), target, stream);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList singletaggedlist = 2;
  if (this->_internal_has_singletaggedlist()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::singletaggedlist(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanMatch)
  return target;
}

size_t VlanIf_VlanMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged singletagged = 1;
  if (this->_internal_has_singletagged()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *singletagged_);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList singletaggedlist = 2;
  if (this->_internal_has_singletaggedlist()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *singletaggedlist_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanMatch::GetClassData() const { return &_class_data_; }

void VlanIf_VlanMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanMatch *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanMatch &>(from));
}


void VlanIf_VlanMatch::MergeFrom(const VlanIf_VlanMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_singletagged()) {
    _internal_mutable_singletagged()->::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged::MergeFrom(from._internal_singletagged());
  }
  if (from._internal_has_singletaggedlist()) {
    _internal_mutable_singletaggedlist()->::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList::MergeFrom(from._internal_singletaggedlist());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanMatch::CopyFrom(const VlanIf_VlanMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanMatch::IsInitialized() const {
  return true;
}

void VlanIf_VlanMatch::InternalSwap(VlanIf_VlanMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VlanIf_VlanMatch, singletaggedlist_)
      + sizeof(VlanIf_VlanMatch::singletaggedlist_)
      - PROTOBUF_FIELD_OFFSET(VlanIf_VlanMatch, singletagged_)>(
          reinterpret_cast<char*>(&singletagged_),
          reinterpret_cast<char*>(&other->singletagged_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanMatch::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[9]);
}

// ===================================================================

class VlanIf_VlanIngressMapping::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& config(const VlanIf_VlanIngressMapping* msg);
  static const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& state(const VlanIf_VlanIngressMapping* msg);
};

const ::opi_api::network::v1alpha1::VlanIngressEgressSetting&
VlanIf_VlanIngressMapping::_Internal::config(const VlanIf_VlanIngressMapping* msg) {
  return *msg->config_;
}
const ::opi_api::network::v1alpha1::VlanIngressEgressSetting&
VlanIf_VlanIngressMapping::_Internal::state(const VlanIf_VlanIngressMapping* msg) {
  return *msg->state_;
}
VlanIf_VlanIngressMapping::VlanIf_VlanIngressMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
}
VlanIf_VlanIngressMapping::VlanIf_VlanIngressMapping(const VlanIf_VlanIngressMapping& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::opi_api::network::v1alpha1::VlanIngressEgressSetting(*from.config_);
  } else {
    config_ = nullptr;
  }
  if (from._internal_has_state()) {
    state_ = new ::opi_api::network::v1alpha1::VlanIngressEgressSetting(*from.state_);
  } else {
    state_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
}

inline void VlanIf_VlanIngressMapping::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&config_)) + sizeof(state_));
}

VlanIf_VlanIngressMapping::~VlanIf_VlanIngressMapping() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanIngressMapping::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
  if (this != internal_default_instance()) delete state_;
}

void VlanIf_VlanIngressMapping::ArenaDtor(void* object) {
  VlanIf_VlanIngressMapping* _this = reinterpret_cast< VlanIf_VlanIngressMapping* >(object);
  (void)_this;
}
void VlanIf_VlanIngressMapping::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanIngressMapping::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanIngressMapping::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanIngressMapping::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanIngressMapping::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
  if (this->_internal_has_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::config(this), target, stream);
  }

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
  if (this->_internal_has_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::state(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
  return target;
}

size_t VlanIf_VlanIngressMapping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
  if (this->_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanIngressMapping::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanIngressMapping::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanIngressMapping::GetClassData() const { return &_class_data_; }

void VlanIf_VlanIngressMapping::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanIngressMapping *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanIngressMapping &>(from));
}


void VlanIf_VlanIngressMapping::MergeFrom(const VlanIf_VlanIngressMapping& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _internal_mutable_config()->::opi_api::network::v1alpha1::VlanIngressEgressSetting::MergeFrom(from._internal_config());
  }
  if (from._internal_has_state()) {
    _internal_mutable_state()->::opi_api::network::v1alpha1::VlanIngressEgressSetting::MergeFrom(from._internal_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanIngressMapping::CopyFrom(const VlanIf_VlanIngressMapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanIngressMapping::IsInitialized() const {
  return true;
}

void VlanIf_VlanIngressMapping::InternalSwap(VlanIf_VlanIngressMapping* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VlanIf_VlanIngressMapping, state_)
      + sizeof(VlanIf_VlanIngressMapping::state_)
      - PROTOBUF_FIELD_OFFSET(VlanIf_VlanIngressMapping, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanIngressMapping::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[10]);
}

// ===================================================================

class VlanIf_VlanEgressMapping::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& config(const VlanIf_VlanEgressMapping* msg);
  static const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& state(const VlanIf_VlanEgressMapping* msg);
};

const ::opi_api::network::v1alpha1::VlanIngressEgressSetting&
VlanIf_VlanEgressMapping::_Internal::config(const VlanIf_VlanEgressMapping* msg) {
  return *msg->config_;
}
const ::opi_api::network::v1alpha1::VlanIngressEgressSetting&
VlanIf_VlanEgressMapping::_Internal::state(const VlanIf_VlanEgressMapping* msg) {
  return *msg->state_;
}
VlanIf_VlanEgressMapping::VlanIf_VlanEgressMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
}
VlanIf_VlanEgressMapping::VlanIf_VlanEgressMapping(const VlanIf_VlanEgressMapping& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::opi_api::network::v1alpha1::VlanIngressEgressSetting(*from.config_);
  } else {
    config_ = nullptr;
  }
  if (from._internal_has_state()) {
    state_ = new ::opi_api::network::v1alpha1::VlanIngressEgressSetting(*from.state_);
  } else {
    state_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
}

inline void VlanIf_VlanEgressMapping::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&config_)) + sizeof(state_));
}

VlanIf_VlanEgressMapping::~VlanIf_VlanEgressMapping() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf_VlanEgressMapping::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
  if (this != internal_default_instance()) delete state_;
}

void VlanIf_VlanEgressMapping::ArenaDtor(void* object) {
  VlanIf_VlanEgressMapping* _this = reinterpret_cast< VlanIf_VlanEgressMapping* >(object);
  (void)_this;
}
void VlanIf_VlanEgressMapping::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf_VlanEgressMapping::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf_VlanEgressMapping::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf_VlanEgressMapping::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf_VlanEgressMapping::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
  if (this->_internal_has_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::config(this), target, stream);
  }

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
  if (this->_internal_has_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::state(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
  return target;
}

size_t VlanIf_VlanEgressMapping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
  if (this->_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf_VlanEgressMapping::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf_VlanEgressMapping::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf_VlanEgressMapping::GetClassData() const { return &_class_data_; }

void VlanIf_VlanEgressMapping::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf_VlanEgressMapping *>(to)->MergeFrom(
      static_cast<const VlanIf_VlanEgressMapping &>(from));
}


void VlanIf_VlanEgressMapping::MergeFrom(const VlanIf_VlanEgressMapping& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _internal_mutable_config()->::opi_api::network::v1alpha1::VlanIngressEgressSetting::MergeFrom(from._internal_config());
  }
  if (from._internal_has_state()) {
    _internal_mutable_state()->::opi_api::network::v1alpha1::VlanIngressEgressSetting::MergeFrom(from._internal_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf_VlanEgressMapping::CopyFrom(const VlanIf_VlanEgressMapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf_VlanEgressMapping::IsInitialized() const {
  return true;
}

void VlanIf_VlanEgressMapping::InternalSwap(VlanIf_VlanEgressMapping* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VlanIf_VlanEgressMapping, state_)
      + sizeof(VlanIf_VlanEgressMapping::state_)
      - PROTOBUF_FIELD_OFFSET(VlanIf_VlanEgressMapping, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf_VlanEgressMapping::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[11]);
}

// ===================================================================

class VlanIf::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::VlanIf_VlanMatch& match(const VlanIf* msg);
  static const ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping& ingressmapping(const VlanIf* msg);
  static const ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping& egressmapping(const VlanIf* msg);
};

const ::opi_api::network::v1alpha1::VlanIf_VlanMatch&
VlanIf::_Internal::match(const VlanIf* msg) {
  return *msg->match_;
}
const ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping&
VlanIf::_Internal::ingressmapping(const VlanIf* msg) {
  return *msg->ingressmapping_;
}
const ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping&
VlanIf::_Internal::egressmapping(const VlanIf* msg) {
  return *msg->egressmapping_;
}
VlanIf::VlanIf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.VlanIf)
}
VlanIf::VlanIf(const VlanIf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match()) {
    match_ = new ::opi_api::network::v1alpha1::VlanIf_VlanMatch(*from.match_);
  } else {
    match_ = nullptr;
  }
  if (from._internal_has_ingressmapping()) {
    ingressmapping_ = new ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping(*from.ingressmapping_);
  } else {
    ingressmapping_ = nullptr;
  }
  if (from._internal_has_egressmapping()) {
    egressmapping_ = new ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping(*from.egressmapping_);
  } else {
    egressmapping_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.VlanIf)
}

inline void VlanIf::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&match_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&egressmapping_) -
    reinterpret_cast<char*>(&match_)) + sizeof(egressmapping_));
}

VlanIf::~VlanIf() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.VlanIf)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VlanIf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete match_;
  if (this != internal_default_instance()) delete ingressmapping_;
  if (this != internal_default_instance()) delete egressmapping_;
}

void VlanIf::ArenaDtor(void* object) {
  VlanIf* _this = reinterpret_cast< VlanIf* >(object);
  (void)_this;
}
void VlanIf::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VlanIf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VlanIf::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.VlanIf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && match_ != nullptr) {
    delete match_;
  }
  match_ = nullptr;
  if (GetArenaForAllocation() == nullptr && ingressmapping_ != nullptr) {
    delete ingressmapping_;
  }
  ingressmapping_ = nullptr;
  if (GetArenaForAllocation() == nullptr && egressmapping_ != nullptr) {
    delete egressmapping_;
  }
  egressmapping_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VlanIf::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.VlanIf.VlanMatch match = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.VlanIf.VlanIngressMapping ingressmapping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ingressmapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.VlanIf.VlanEgressMapping egressmapping = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_egressmapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VlanIf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.VlanIf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch match = 1;
  if (this->_internal_has_match()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::match(this), target, stream);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanIngressMapping ingressmapping = 2;
  if (this->_internal_has_ingressmapping()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ingressmapping(this), target, stream);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanEgressMapping egressmapping = 3;
  if (this->_internal_has_egressmapping()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::egressmapping(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.VlanIf)
  return target;
}

size_t VlanIf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.VlanIf)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch match = 1;
  if (this->_internal_has_match()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *match_);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanIngressMapping ingressmapping = 2;
  if (this->_internal_has_ingressmapping()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ingressmapping_);
  }

  // .opi_api.network.v1alpha1.VlanIf.VlanEgressMapping egressmapping = 3;
  if (this->_internal_has_egressmapping()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *egressmapping_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VlanIf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VlanIf::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VlanIf::GetClassData() const { return &_class_data_; }

void VlanIf::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VlanIf *>(to)->MergeFrom(
      static_cast<const VlanIf &>(from));
}


void VlanIf::MergeFrom(const VlanIf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.VlanIf)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_match()) {
    _internal_mutable_match()->::opi_api::network::v1alpha1::VlanIf_VlanMatch::MergeFrom(from._internal_match());
  }
  if (from._internal_has_ingressmapping()) {
    _internal_mutable_ingressmapping()->::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping::MergeFrom(from._internal_ingressmapping());
  }
  if (from._internal_has_egressmapping()) {
    _internal_mutable_egressmapping()->::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping::MergeFrom(from._internal_egressmapping());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VlanIf::CopyFrom(const VlanIf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.VlanIf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VlanIf::IsInitialized() const {
  return true;
}

void VlanIf::InternalSwap(VlanIf* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VlanIf, egressmapping_)
      + sizeof(VlanIf::egressmapping_)
      - PROTOBUF_FIELD_OFFSET(VlanIf, match_)>(
          reinterpret_cast<char*>(&match_),
          reinterpret_cast<char*>(&other->match_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VlanIf::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fvlan_2eproto_getter, &descriptor_table_openconfig_5fvlan_2eproto_once,
      file_level_metadata_openconfig_5fvlan_2eproto[12]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::SwitchedVlanSetting* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::SwitchedVlanSetting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::SwitchedVlanSetting >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanSwitchedIf* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanSwitchedIf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanSwitchedIf >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIngressEgressSetting* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIngressEgressSetting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIngressEgressSetting >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanMatch* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::VlanIf* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::VlanIf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::VlanIf >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
