// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openconfig_ethernet.proto

#include "openconfig_ethernet.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace opi_api {
namespace network {
namespace v1alpha1 {
constexpr EthernetConfig::EthernetConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mac_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , auto_negotiate_(false)
  , standalone_link_training_(false)
  , enable_flow_control_(false)
  , duplex_mode_(0)

  , port_speed_(0)

  , fec_mode_(0)
{}
struct EthernetConfigDefaultTypeInternal {
  constexpr EthernetConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EthernetConfigDefaultTypeInternal() {}
  union {
    EthernetConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EthernetConfigDefaultTypeInternal _EthernetConfig_default_instance_;
constexpr EthernetInDistribution::EthernetInDistribution(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : rx_frames_octets64_(uint64_t{0u})
  , rx_frames_octets65_to127_(uint64_t{0u})
  , rx_frames_octets128_to255_(uint64_t{0u})
  , rx_frames_octets256_to511_(uint64_t{0u})
  , rx_frames_octets512_to1023_(uint64_t{0u})
  , rx_frames_octets1024_to1518_(uint64_t{0u}){}
struct EthernetInDistributionDefaultTypeInternal {
  constexpr EthernetInDistributionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EthernetInDistributionDefaultTypeInternal() {}
  union {
    EthernetInDistribution _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EthernetInDistributionDefaultTypeInternal _EthernetInDistribution_default_instance_;
constexpr EthernetCounters::EthernetCounters(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : eth_rx_distribution_(nullptr)
  , rx_mac_control_frames_(uint64_t{0u})
  , rx_mac_pause_frames_(uint64_t{0u})
  , rx_oversize_frames_(uint64_t{0u})
  , rx_undersize_frames_(uint64_t{0u})
  , rx_jabber_frames_(uint64_t{0u})
  , rx_fragment_frames_(uint64_t{0u})
  , rx_ieee8021q_frames_(uint64_t{0u})
  , rx_crc_errors_(uint64_t{0u})
  , rx_block_errors_(uint64_t{0u})
  , rx_carrier_errors_(uint64_t{0u})
  , rx_interrupted_tx_(uint64_t{0u})
  , rx_late_collision_(uint64_t{0u})
  , rx_mac_errors_rx_(uint64_t{0u})
  , rx_single_collision_(uint64_t{0u})
  , rx_symbol_error_(uint64_t{0u})
  , rx_maxsize_exceeded_(uint64_t{0u})
  , out_mac_control_frames_(uint64_t{0u})
  , out_mac_pause_frames_(uint64_t{0u})
  , out_ieee8021q_frames_(uint64_t{0u})
  , out_mac_errors_tx_(uint64_t{0u}){}
struct EthernetCountersDefaultTypeInternal {
  constexpr EthernetCountersDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EthernetCountersDefaultTypeInternal() {}
  union {
    EthernetCounters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EthernetCountersDefaultTypeInternal _EthernetCounters_default_instance_;
constexpr EthernetState::EthernetState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mac_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hw_mac_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , counters_(nullptr)
  , auto_negotiate_(false)
  , standalone_link_training_(false)
  , enable_flow_control_(false)
  , duplex_mode_(0)

  , port_speed_(0)

  , fec_mode_(0)

  , negotiated_duplex_mode_(0)

  , negotiated_port_speed_(0)
{}
struct EthernetStateDefaultTypeInternal {
  constexpr EthernetStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EthernetStateDefaultTypeInternal() {}
  union {
    EthernetState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EthernetStateDefaultTypeInternal _EthernetState_default_instance_;
constexpr EthernetIf::EthernetIf(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr)
  , state_(nullptr)
  , switched_vlan_(nullptr){}
struct EthernetIfDefaultTypeInternal {
  constexpr EthernetIfDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EthernetIfDefaultTypeInternal() {}
  union {
    EthernetIf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EthernetIfDefaultTypeInternal _EthernetIf_default_instance_;
}  // namespace v1alpha1
}  // namespace network
}  // namespace opi_api
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_openconfig_5fethernet_2eproto[5];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_openconfig_5fethernet_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_openconfig_5fethernet_2eproto = nullptr;

const uint32_t TableStruct_openconfig_5fethernet_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetConfig, mac_address_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetConfig, auto_negotiate_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetConfig, standalone_link_training_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetConfig, duplex_mode_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetConfig, port_speed_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetConfig, enable_flow_control_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetConfig, fec_mode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetInDistribution, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetInDistribution, rx_frames_octets64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetInDistribution, rx_frames_octets65_to127_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetInDistribution, rx_frames_octets128_to255_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetInDistribution, rx_frames_octets256_to511_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetInDistribution, rx_frames_octets512_to1023_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetInDistribution, rx_frames_octets1024_to1518_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_mac_control_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_mac_pause_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_oversize_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_undersize_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_jabber_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_fragment_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_ieee8021q_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_crc_errors_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_block_errors_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_carrier_errors_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_interrupted_tx_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_late_collision_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_mac_errors_rx_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_single_collision_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_symbol_error_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, rx_maxsize_exceeded_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, out_mac_control_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, out_mac_pause_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, out_ieee8021q_frames_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, out_mac_errors_tx_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetCounters, eth_rx_distribution_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, mac_address_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, auto_negotiate_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, standalone_link_training_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, duplex_mode_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, port_speed_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, enable_flow_control_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, fec_mode_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, hw_mac_address_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, negotiated_duplex_mode_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, negotiated_port_speed_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetState, counters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetIf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetIf, config_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetIf, state_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::v1alpha1::EthernetIf, switched_vlan_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::network::v1alpha1::EthernetConfig)},
  { 13, -1, -1, sizeof(::opi_api::network::v1alpha1::EthernetInDistribution)},
  { 25, -1, -1, sizeof(::opi_api::network::v1alpha1::EthernetCounters)},
  { 52, -1, -1, sizeof(::opi_api::network::v1alpha1::EthernetState)},
  { 69, -1, -1, sizeof(::opi_api::network::v1alpha1::EthernetIf)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_EthernetConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_EthernetInDistribution_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_EthernetCounters_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_EthernetState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::network::v1alpha1::_EthernetIf_default_instance_),
};

const char descriptor_table_protodef_openconfig_5fethernet_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\031openconfig_ethernet.proto\022\030opi_api.net"
  "work.v1alpha1\032\025openconfig_vlan.proto\032\037go"
  "ogle/api/field_behavior.proto\"\321\002\n\016Ethern"
  "etConfig\022\030\n\013mac_address\030\001 \001(\tB\003\340A\001\022\033\n\016au"
  "to_negotiate\030\002 \001(\010B\003\340A\001\022%\n\030standalone_li"
  "nk_training\030\003 \001(\010B\003\340A\001\022A\n\013duplex_mode\030\004 "
  "\001(\0162\'.opi_api.network.v1alpha1.EthDuplex"
  "ModeB\003\340A\001\022\?\n\nport_speed\030\005 \001(\0162&.opi_api."
  "network.v1alpha1.EthPortSpeedB\003\340A\001\022 \n\023en"
  "able_flow_control\030\006 \001(\010B\003\340A\001\022;\n\010fec_mode"
  "\030\007 \001(\0162$.opi_api.network.v1alpha1.EthFec"
  "ModeB\003\340A\001\"\345\001\n\026EthernetInDistribution\022\032\n\022"
  "rx_frames_octets64\030\001 \001(\004\022 \n\030rx_frames_oc"
  "tets65_to127\030\002 \001(\004\022!\n\031rx_frames_octets12"
  "8_to255\030\003 \001(\004\022!\n\031rx_frames_octets256_to5"
  "11\030\004 \001(\004\022\"\n\032rx_frames_octets512_to1023\030\005"
  " \001(\004\022#\n\033rx_frames_octets1024_to1518\030\006 \001("
  "\004\"\216\005\n\020EthernetCounters\022\035\n\025rx_mac_control"
  "_frames\030\001 \001(\004\022\033\n\023rx_mac_pause_frames\030\002 \001"
  "(\004\022\032\n\022rx_oversize_frames\030\003 \001(\004\022\033\n\023rx_und"
  "ersize_frames\030\004 \001(\004\022\030\n\020rx_jabber_frames\030"
  "\005 \001(\004\022\032\n\022rx_fragment_frames\030\006 \001(\004\022\033\n\023rx_"
  "ieee8021q_frames\030\007 \001(\004\022\025\n\rrx_crc_errors\030"
  "\010 \001(\004\022\027\n\017rx_block_errors\030\t \001(\004\022\031\n\021rx_car"
  "rier_errors\030\n \001(\004\022\031\n\021rx_interrupted_tx\030\013"
  " \001(\004\022\031\n\021rx_late_collision\030\014 \001(\004\022\030\n\020rx_ma"
  "c_errors_rx\030\r \001(\004\022\033\n\023rx_single_collision"
  "\030\016 \001(\004\022\027\n\017rx_symbol_error\030\017 \001(\004\022\033\n\023rx_ma"
  "xsize_exceeded\030\020 \001(\004\022\036\n\026out_mac_control_"
  "frames\030\021 \001(\004\022\034\n\024out_mac_pause_frames\030\022 \001"
  "(\004\022\034\n\024out_ieee8021q_frames\030\023 \001(\004\022\031\n\021out_"
  "mac_errors_tx\030\024 \001(\004\022M\n\023eth_rx_distributi"
  "on\030\025 \001(\01320.opi_api.network.v1alpha1.Ethe"
  "rnetInDistribution\"\223\004\n\rEthernetState\022\023\n\013"
  "mac_address\030\001 \001(\t\022\026\n\016auto_negotiate\030\002 \001("
  "\010\022 \n\030standalone_link_training\030\003 \001(\010\022<\n\013d"
  "uplex_mode\030\004 \001(\0162\'.opi_api.network.v1alp"
  "ha1.EthDuplexMode\022:\n\nport_speed\030\005 \001(\0162&."
  "opi_api.network.v1alpha1.EthPortSpeed\022\033\n"
  "\023enable_flow_control\030\006 \001(\010\0226\n\010fec_mode\030\007"
  " \001(\0162$.opi_api.network.v1alpha1.EthFecMo"
  "de\022\026\n\016hw_mac_address\030\010 \001(\t\022G\n\026negotiated"
  "_duplex_mode\030\t \001(\0162\'.opi_api.network.v1a"
  "lpha1.EthDuplexMode\022E\n\025negotiated_port_s"
  "peed\030\n \001(\0162&.opi_api.network.v1alpha1.Et"
  "hPortSpeed\022<\n\010counters\030\013 \001(\0132*.opi_api.n"
  "etwork.v1alpha1.EthernetCounters\"\277\001\n\nEth"
  "ernetIf\0228\n\006config\030\001 \001(\0132(.opi_api.networ"
  "k.v1alpha1.EthernetConfig\0226\n\005state\030\002 \001(\013"
  "2\'.opi_api.network.v1alpha1.EthernetStat"
  "e\022\?\n\rswitched_vlan\030\003 \001(\0132(.opi_api.netwo"
  "rk.v1alpha1.VlanSwitchedIf*d\n\rEthDuplexM"
  "ode\022\037\n\033ETH_DUPLEX_MODE_UNSPECIFIED\020\000\022\030\n\024"
  "ETH_DUPLEX_MODE_FULL\020\001\022\030\n\024ETH_DUPLEX_MOD"
  "E_HALF\020\002*\240\003\n\014EthPortSpeed\022\036\n\032ETH_PORT_SP"
  "EED_UNSPECIFIED\020\000\022\026\n\022ETH_PORT_SPEED_10M\020"
  "\001\022\027\n\023ETH_PORT_SPEED_100M\020\002\022\025\n\021ETH_PORT_S"
  "PEED_1G\020\003\022\030\n\024ETH_PORT_SPEED_2500M\020\004\022\025\n\021E"
  "TH_PORT_SPEED_5G\020\005\022\026\n\022ETH_PORT_SPEED_10G"
  "\020\006\022\026\n\022ETH_PORT_SPEED_25G\020\007\022\026\n\022ETH_PORT_S"
  "PEED_40G\020\010\022\026\n\022ETH_PORT_SPEED_50G\020\t\022\027\n\023ET"
  "H_PORT_SPEED_100G\020\n\022\027\n\023ETH_PORT_SPEED_20"
  "0G\020\013\022\027\n\023ETH_PORT_SPEED_400G\020\014\022\027\n\023ETH_POR"
  "T_SPEED_600G\020\r\022\027\n\023ETH_PORT_SPEED_800G\020\016\022"
  "\032\n\026ETH_PORT_SPEED_UNKNOWN\020\017*\260\001\n\nEthFecMo"
  "de\022\034\n\030ETH_FEC_MODE_UNSPECIFIED\020\000\022\023\n\017ETH_"
  "FEC_MODE_FC\020\001\022\026\n\022ETH_FEC_MODE_RS528\020\002\022\026\n"
  "\022ETH_FEC_MODE_RS544\020\003\022$\n ETH_FEC_MODE_RS"
  "544_2X_INTERLEAVE\020\004\022\031\n\025ETH_FEC_MODE_DISA"
  "BLED\020\005By\n\030opi_api.network.v1alpha1B\027Open"
  "configEthernetProtoP\001ZBgithub.com/opipro"
  "ject/opi-api/network/opinetcommon/v1alph"
  "a1/gen/gob\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_openconfig_5fethernet_2eproto_deps[2] = {
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_openconfig_5fvlan_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_openconfig_5fethernet_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openconfig_5fethernet_2eproto = {
  false, false, 2897, descriptor_table_protodef_openconfig_5fethernet_2eproto, "openconfig_ethernet.proto", 
  &descriptor_table_openconfig_5fethernet_2eproto_once, descriptor_table_openconfig_5fethernet_2eproto_deps, 2, 5,
  schemas, file_default_instances, TableStruct_openconfig_5fethernet_2eproto::offsets,
  file_level_metadata_openconfig_5fethernet_2eproto, file_level_enum_descriptors_openconfig_5fethernet_2eproto, file_level_service_descriptors_openconfig_5fethernet_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_openconfig_5fethernet_2eproto_getter() {
  return &descriptor_table_openconfig_5fethernet_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_openconfig_5fethernet_2eproto(&descriptor_table_openconfig_5fethernet_2eproto);
namespace opi_api {
namespace network {
namespace v1alpha1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EthDuplexMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_openconfig_5fethernet_2eproto);
  return file_level_enum_descriptors_openconfig_5fethernet_2eproto[0];
}
bool EthDuplexMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EthPortSpeed_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_openconfig_5fethernet_2eproto);
  return file_level_enum_descriptors_openconfig_5fethernet_2eproto[1];
}
bool EthPortSpeed_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EthFecMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_openconfig_5fethernet_2eproto);
  return file_level_enum_descriptors_openconfig_5fethernet_2eproto[2];
}
bool EthFecMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class EthernetConfig::_Internal {
 public:
};

EthernetConfig::EthernetConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.EthernetConfig)
}
EthernetConfig::EthernetConfig(const EthernetConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac_address().empty()) {
    mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mac_address(), 
      GetArenaForAllocation());
  }
  ::memcpy(&auto_negotiate_, &from.auto_negotiate_,
    static_cast<size_t>(reinterpret_cast<char*>(&fec_mode_) -
    reinterpret_cast<char*>(&auto_negotiate_)) + sizeof(fec_mode_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.EthernetConfig)
}

inline void EthernetConfig::SharedCtor() {
mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&auto_negotiate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fec_mode_) -
    reinterpret_cast<char*>(&auto_negotiate_)) + sizeof(fec_mode_));
}

EthernetConfig::~EthernetConfig() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.EthernetConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EthernetConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  mac_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EthernetConfig::ArenaDtor(void* object) {
  EthernetConfig* _this = reinterpret_cast< EthernetConfig* >(object);
  (void)_this;
}
void EthernetConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EthernetConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EthernetConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.EthernetConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mac_address_.ClearToEmpty();
  ::memset(&auto_negotiate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fec_mode_) -
      reinterpret_cast<char*>(&auto_negotiate_)) + sizeof(fec_mode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EthernetConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string mac_address = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.network.v1alpha1.EthernetConfig.mac_address"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool auto_negotiate = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          auto_negotiate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool standalone_link_training = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          standalone_link_training_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthDuplexMode duplex_mode = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_duplex_mode(static_cast<::opi_api::network::v1alpha1::EthDuplexMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthPortSpeed port_speed = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_port_speed(static_cast<::opi_api::network::v1alpha1::EthPortSpeed>(val));
        } else
          goto handle_unusual;
        continue;
      // bool enable_flow_control = 6 [(.google.api.field_behavior) = OPTIONAL];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          enable_flow_control_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthFecMode fec_mode = 7 [(.google.api.field_behavior) = OPTIONAL];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_fec_mode(static_cast<::opi_api::network::v1alpha1::EthFecMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EthernetConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.EthernetConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string mac_address = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_mac_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac_address().data(), static_cast<int>(this->_internal_mac_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.v1alpha1.EthernetConfig.mac_address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mac_address(), target);
  }

  // bool auto_negotiate = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_auto_negotiate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_auto_negotiate(), target);
  }

  // bool standalone_link_training = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_standalone_link_training() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_standalone_link_training(), target);
  }

  // .opi_api.network.v1alpha1.EthDuplexMode duplex_mode = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_duplex_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_duplex_mode(), target);
  }

  // .opi_api.network.v1alpha1.EthPortSpeed port_speed = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_port_speed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_port_speed(), target);
  }

  // bool enable_flow_control = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_enable_flow_control() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_enable_flow_control(), target);
  }

  // .opi_api.network.v1alpha1.EthFecMode fec_mode = 7 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_fec_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_fec_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.EthernetConfig)
  return target;
}

size_t EthernetConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.EthernetConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mac_address = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_mac_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac_address());
  }

  // bool auto_negotiate = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_auto_negotiate() != 0) {
    total_size += 1 + 1;
  }

  // bool standalone_link_training = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_standalone_link_training() != 0) {
    total_size += 1 + 1;
  }

  // bool enable_flow_control = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_enable_flow_control() != 0) {
    total_size += 1 + 1;
  }

  // .opi_api.network.v1alpha1.EthDuplexMode duplex_mode = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_duplex_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_duplex_mode());
  }

  // .opi_api.network.v1alpha1.EthPortSpeed port_speed = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_port_speed() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_port_speed());
  }

  // .opi_api.network.v1alpha1.EthFecMode fec_mode = 7 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_fec_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_fec_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EthernetConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EthernetConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EthernetConfig::GetClassData() const { return &_class_data_; }

void EthernetConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EthernetConfig *>(to)->MergeFrom(
      static_cast<const EthernetConfig &>(from));
}


void EthernetConfig::MergeFrom(const EthernetConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.EthernetConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mac_address().empty()) {
    _internal_set_mac_address(from._internal_mac_address());
  }
  if (from._internal_auto_negotiate() != 0) {
    _internal_set_auto_negotiate(from._internal_auto_negotiate());
  }
  if (from._internal_standalone_link_training() != 0) {
    _internal_set_standalone_link_training(from._internal_standalone_link_training());
  }
  if (from._internal_enable_flow_control() != 0) {
    _internal_set_enable_flow_control(from._internal_enable_flow_control());
  }
  if (from._internal_duplex_mode() != 0) {
    _internal_set_duplex_mode(from._internal_duplex_mode());
  }
  if (from._internal_port_speed() != 0) {
    _internal_set_port_speed(from._internal_port_speed());
  }
  if (from._internal_fec_mode() != 0) {
    _internal_set_fec_mode(from._internal_fec_mode());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EthernetConfig::CopyFrom(const EthernetConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.EthernetConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthernetConfig::IsInitialized() const {
  return true;
}

void EthernetConfig::InternalSwap(EthernetConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mac_address_, lhs_arena,
      &other->mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EthernetConfig, fec_mode_)
      + sizeof(EthernetConfig::fec_mode_)
      - PROTOBUF_FIELD_OFFSET(EthernetConfig, auto_negotiate_)>(
          reinterpret_cast<char*>(&auto_negotiate_),
          reinterpret_cast<char*>(&other->auto_negotiate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EthernetConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fethernet_2eproto_getter, &descriptor_table_openconfig_5fethernet_2eproto_once,
      file_level_metadata_openconfig_5fethernet_2eproto[0]);
}

// ===================================================================

class EthernetInDistribution::_Internal {
 public:
};

EthernetInDistribution::EthernetInDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.EthernetInDistribution)
}
EthernetInDistribution::EthernetInDistribution(const EthernetInDistribution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&rx_frames_octets64_, &from.rx_frames_octets64_,
    static_cast<size_t>(reinterpret_cast<char*>(&rx_frames_octets1024_to1518_) -
    reinterpret_cast<char*>(&rx_frames_octets64_)) + sizeof(rx_frames_octets1024_to1518_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.EthernetInDistribution)
}

inline void EthernetInDistribution::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rx_frames_octets64_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rx_frames_octets1024_to1518_) -
    reinterpret_cast<char*>(&rx_frames_octets64_)) + sizeof(rx_frames_octets1024_to1518_));
}

EthernetInDistribution::~EthernetInDistribution() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.EthernetInDistribution)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EthernetInDistribution::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EthernetInDistribution::ArenaDtor(void* object) {
  EthernetInDistribution* _this = reinterpret_cast< EthernetInDistribution* >(object);
  (void)_this;
}
void EthernetInDistribution::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EthernetInDistribution::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EthernetInDistribution::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.EthernetInDistribution)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&rx_frames_octets64_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rx_frames_octets1024_to1518_) -
      reinterpret_cast<char*>(&rx_frames_octets64_)) + sizeof(rx_frames_octets1024_to1518_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EthernetInDistribution::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 rx_frames_octets64 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          rx_frames_octets64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_frames_octets65_to127 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          rx_frames_octets65_to127_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_frames_octets128_to255 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          rx_frames_octets128_to255_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_frames_octets256_to511 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          rx_frames_octets256_to511_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_frames_octets512_to1023 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          rx_frames_octets512_to1023_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_frames_octets1024_to1518 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          rx_frames_octets1024_to1518_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EthernetInDistribution::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.EthernetInDistribution)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 rx_frames_octets64 = 1;
  if (this->_internal_rx_frames_octets64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_rx_frames_octets64(), target);
  }

  // uint64 rx_frames_octets65_to127 = 2;
  if (this->_internal_rx_frames_octets65_to127() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_rx_frames_octets65_to127(), target);
  }

  // uint64 rx_frames_octets128_to255 = 3;
  if (this->_internal_rx_frames_octets128_to255() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_rx_frames_octets128_to255(), target);
  }

  // uint64 rx_frames_octets256_to511 = 4;
  if (this->_internal_rx_frames_octets256_to511() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_rx_frames_octets256_to511(), target);
  }

  // uint64 rx_frames_octets512_to1023 = 5;
  if (this->_internal_rx_frames_octets512_to1023() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_rx_frames_octets512_to1023(), target);
  }

  // uint64 rx_frames_octets1024_to1518 = 6;
  if (this->_internal_rx_frames_octets1024_to1518() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_rx_frames_octets1024_to1518(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.EthernetInDistribution)
  return target;
}

size_t EthernetInDistribution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.EthernetInDistribution)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 rx_frames_octets64 = 1;
  if (this->_internal_rx_frames_octets64() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_frames_octets64());
  }

  // uint64 rx_frames_octets65_to127 = 2;
  if (this->_internal_rx_frames_octets65_to127() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_frames_octets65_to127());
  }

  // uint64 rx_frames_octets128_to255 = 3;
  if (this->_internal_rx_frames_octets128_to255() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_frames_octets128_to255());
  }

  // uint64 rx_frames_octets256_to511 = 4;
  if (this->_internal_rx_frames_octets256_to511() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_frames_octets256_to511());
  }

  // uint64 rx_frames_octets512_to1023 = 5;
  if (this->_internal_rx_frames_octets512_to1023() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_frames_octets512_to1023());
  }

  // uint64 rx_frames_octets1024_to1518 = 6;
  if (this->_internal_rx_frames_octets1024_to1518() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_frames_octets1024_to1518());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EthernetInDistribution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EthernetInDistribution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EthernetInDistribution::GetClassData() const { return &_class_data_; }

void EthernetInDistribution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EthernetInDistribution *>(to)->MergeFrom(
      static_cast<const EthernetInDistribution &>(from));
}


void EthernetInDistribution::MergeFrom(const EthernetInDistribution& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.EthernetInDistribution)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_rx_frames_octets64() != 0) {
    _internal_set_rx_frames_octets64(from._internal_rx_frames_octets64());
  }
  if (from._internal_rx_frames_octets65_to127() != 0) {
    _internal_set_rx_frames_octets65_to127(from._internal_rx_frames_octets65_to127());
  }
  if (from._internal_rx_frames_octets128_to255() != 0) {
    _internal_set_rx_frames_octets128_to255(from._internal_rx_frames_octets128_to255());
  }
  if (from._internal_rx_frames_octets256_to511() != 0) {
    _internal_set_rx_frames_octets256_to511(from._internal_rx_frames_octets256_to511());
  }
  if (from._internal_rx_frames_octets512_to1023() != 0) {
    _internal_set_rx_frames_octets512_to1023(from._internal_rx_frames_octets512_to1023());
  }
  if (from._internal_rx_frames_octets1024_to1518() != 0) {
    _internal_set_rx_frames_octets1024_to1518(from._internal_rx_frames_octets1024_to1518());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EthernetInDistribution::CopyFrom(const EthernetInDistribution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.EthernetInDistribution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthernetInDistribution::IsInitialized() const {
  return true;
}

void EthernetInDistribution::InternalSwap(EthernetInDistribution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EthernetInDistribution, rx_frames_octets1024_to1518_)
      + sizeof(EthernetInDistribution::rx_frames_octets1024_to1518_)
      - PROTOBUF_FIELD_OFFSET(EthernetInDistribution, rx_frames_octets64_)>(
          reinterpret_cast<char*>(&rx_frames_octets64_),
          reinterpret_cast<char*>(&other->rx_frames_octets64_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EthernetInDistribution::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fethernet_2eproto_getter, &descriptor_table_openconfig_5fethernet_2eproto_once,
      file_level_metadata_openconfig_5fethernet_2eproto[1]);
}

// ===================================================================

class EthernetCounters::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::EthernetInDistribution& eth_rx_distribution(const EthernetCounters* msg);
};

const ::opi_api::network::v1alpha1::EthernetInDistribution&
EthernetCounters::_Internal::eth_rx_distribution(const EthernetCounters* msg) {
  return *msg->eth_rx_distribution_;
}
EthernetCounters::EthernetCounters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.EthernetCounters)
}
EthernetCounters::EthernetCounters(const EthernetCounters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_eth_rx_distribution()) {
    eth_rx_distribution_ = new ::opi_api::network::v1alpha1::EthernetInDistribution(*from.eth_rx_distribution_);
  } else {
    eth_rx_distribution_ = nullptr;
  }
  ::memcpy(&rx_mac_control_frames_, &from.rx_mac_control_frames_,
    static_cast<size_t>(reinterpret_cast<char*>(&out_mac_errors_tx_) -
    reinterpret_cast<char*>(&rx_mac_control_frames_)) + sizeof(out_mac_errors_tx_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.EthernetCounters)
}

inline void EthernetCounters::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&eth_rx_distribution_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&out_mac_errors_tx_) -
    reinterpret_cast<char*>(&eth_rx_distribution_)) + sizeof(out_mac_errors_tx_));
}

EthernetCounters::~EthernetCounters() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.EthernetCounters)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EthernetCounters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete eth_rx_distribution_;
}

void EthernetCounters::ArenaDtor(void* object) {
  EthernetCounters* _this = reinterpret_cast< EthernetCounters* >(object);
  (void)_this;
}
void EthernetCounters::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EthernetCounters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EthernetCounters::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.EthernetCounters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && eth_rx_distribution_ != nullptr) {
    delete eth_rx_distribution_;
  }
  eth_rx_distribution_ = nullptr;
  ::memset(&rx_mac_control_frames_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&out_mac_errors_tx_) -
      reinterpret_cast<char*>(&rx_mac_control_frames_)) + sizeof(out_mac_errors_tx_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EthernetCounters::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 rx_mac_control_frames = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          rx_mac_control_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_mac_pause_frames = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          rx_mac_pause_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_oversize_frames = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          rx_oversize_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_undersize_frames = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          rx_undersize_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_jabber_frames = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          rx_jabber_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_fragment_frames = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          rx_fragment_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_ieee8021q_frames = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          rx_ieee8021q_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_crc_errors = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          rx_crc_errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_block_errors = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          rx_block_errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_carrier_errors = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          rx_carrier_errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_interrupted_tx = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          rx_interrupted_tx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_late_collision = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          rx_late_collision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_mac_errors_rx = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          rx_mac_errors_rx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_single_collision = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          rx_single_collision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_symbol_error = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          rx_symbol_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_maxsize_exceeded = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          rx_maxsize_exceeded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 out_mac_control_frames = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          out_mac_control_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 out_mac_pause_frames = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          out_mac_pause_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 out_ieee8021q_frames = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          out_ieee8021q_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 out_mac_errors_tx = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          out_mac_errors_tx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthernetInDistribution eth_rx_distribution = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_eth_rx_distribution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EthernetCounters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.EthernetCounters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 rx_mac_control_frames = 1;
  if (this->_internal_rx_mac_control_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_rx_mac_control_frames(), target);
  }

  // uint64 rx_mac_pause_frames = 2;
  if (this->_internal_rx_mac_pause_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_rx_mac_pause_frames(), target);
  }

  // uint64 rx_oversize_frames = 3;
  if (this->_internal_rx_oversize_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_rx_oversize_frames(), target);
  }

  // uint64 rx_undersize_frames = 4;
  if (this->_internal_rx_undersize_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_rx_undersize_frames(), target);
  }

  // uint64 rx_jabber_frames = 5;
  if (this->_internal_rx_jabber_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_rx_jabber_frames(), target);
  }

  // uint64 rx_fragment_frames = 6;
  if (this->_internal_rx_fragment_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_rx_fragment_frames(), target);
  }

  // uint64 rx_ieee8021q_frames = 7;
  if (this->_internal_rx_ieee8021q_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_rx_ieee8021q_frames(), target);
  }

  // uint64 rx_crc_errors = 8;
  if (this->_internal_rx_crc_errors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_rx_crc_errors(), target);
  }

  // uint64 rx_block_errors = 9;
  if (this->_internal_rx_block_errors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_rx_block_errors(), target);
  }

  // uint64 rx_carrier_errors = 10;
  if (this->_internal_rx_carrier_errors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(10, this->_internal_rx_carrier_errors(), target);
  }

  // uint64 rx_interrupted_tx = 11;
  if (this->_internal_rx_interrupted_tx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(11, this->_internal_rx_interrupted_tx(), target);
  }

  // uint64 rx_late_collision = 12;
  if (this->_internal_rx_late_collision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(12, this->_internal_rx_late_collision(), target);
  }

  // uint64 rx_mac_errors_rx = 13;
  if (this->_internal_rx_mac_errors_rx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(13, this->_internal_rx_mac_errors_rx(), target);
  }

  // uint64 rx_single_collision = 14;
  if (this->_internal_rx_single_collision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(14, this->_internal_rx_single_collision(), target);
  }

  // uint64 rx_symbol_error = 15;
  if (this->_internal_rx_symbol_error() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(15, this->_internal_rx_symbol_error(), target);
  }

  // uint64 rx_maxsize_exceeded = 16;
  if (this->_internal_rx_maxsize_exceeded() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(16, this->_internal_rx_maxsize_exceeded(), target);
  }

  // uint64 out_mac_control_frames = 17;
  if (this->_internal_out_mac_control_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(17, this->_internal_out_mac_control_frames(), target);
  }

  // uint64 out_mac_pause_frames = 18;
  if (this->_internal_out_mac_pause_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(18, this->_internal_out_mac_pause_frames(), target);
  }

  // uint64 out_ieee8021q_frames = 19;
  if (this->_internal_out_ieee8021q_frames() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(19, this->_internal_out_ieee8021q_frames(), target);
  }

  // uint64 out_mac_errors_tx = 20;
  if (this->_internal_out_mac_errors_tx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(20, this->_internal_out_mac_errors_tx(), target);
  }

  // .opi_api.network.v1alpha1.EthernetInDistribution eth_rx_distribution = 21;
  if (this->_internal_has_eth_rx_distribution()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::eth_rx_distribution(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.EthernetCounters)
  return target;
}

size_t EthernetCounters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.EthernetCounters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.EthernetInDistribution eth_rx_distribution = 21;
  if (this->_internal_has_eth_rx_distribution()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *eth_rx_distribution_);
  }

  // uint64 rx_mac_control_frames = 1;
  if (this->_internal_rx_mac_control_frames() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_mac_control_frames());
  }

  // uint64 rx_mac_pause_frames = 2;
  if (this->_internal_rx_mac_pause_frames() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_mac_pause_frames());
  }

  // uint64 rx_oversize_frames = 3;
  if (this->_internal_rx_oversize_frames() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_oversize_frames());
  }

  // uint64 rx_undersize_frames = 4;
  if (this->_internal_rx_undersize_frames() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_undersize_frames());
  }

  // uint64 rx_jabber_frames = 5;
  if (this->_internal_rx_jabber_frames() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_jabber_frames());
  }

  // uint64 rx_fragment_frames = 6;
  if (this->_internal_rx_fragment_frames() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_fragment_frames());
  }

  // uint64 rx_ieee8021q_frames = 7;
  if (this->_internal_rx_ieee8021q_frames() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_ieee8021q_frames());
  }

  // uint64 rx_crc_errors = 8;
  if (this->_internal_rx_crc_errors() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_crc_errors());
  }

  // uint64 rx_block_errors = 9;
  if (this->_internal_rx_block_errors() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_block_errors());
  }

  // uint64 rx_carrier_errors = 10;
  if (this->_internal_rx_carrier_errors() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_carrier_errors());
  }

  // uint64 rx_interrupted_tx = 11;
  if (this->_internal_rx_interrupted_tx() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_interrupted_tx());
  }

  // uint64 rx_late_collision = 12;
  if (this->_internal_rx_late_collision() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_late_collision());
  }

  // uint64 rx_mac_errors_rx = 13;
  if (this->_internal_rx_mac_errors_rx() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_mac_errors_rx());
  }

  // uint64 rx_single_collision = 14;
  if (this->_internal_rx_single_collision() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_single_collision());
  }

  // uint64 rx_symbol_error = 15;
  if (this->_internal_rx_symbol_error() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_symbol_error());
  }

  // uint64 rx_maxsize_exceeded = 16;
  if (this->_internal_rx_maxsize_exceeded() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_rx_maxsize_exceeded());
  }

  // uint64 out_mac_control_frames = 17;
  if (this->_internal_out_mac_control_frames() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_out_mac_control_frames());
  }

  // uint64 out_mac_pause_frames = 18;
  if (this->_internal_out_mac_pause_frames() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_out_mac_pause_frames());
  }

  // uint64 out_ieee8021q_frames = 19;
  if (this->_internal_out_ieee8021q_frames() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_out_ieee8021q_frames());
  }

  // uint64 out_mac_errors_tx = 20;
  if (this->_internal_out_mac_errors_tx() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_out_mac_errors_tx());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EthernetCounters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EthernetCounters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EthernetCounters::GetClassData() const { return &_class_data_; }

void EthernetCounters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EthernetCounters *>(to)->MergeFrom(
      static_cast<const EthernetCounters &>(from));
}


void EthernetCounters::MergeFrom(const EthernetCounters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.EthernetCounters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eth_rx_distribution()) {
    _internal_mutable_eth_rx_distribution()->::opi_api::network::v1alpha1::EthernetInDistribution::MergeFrom(from._internal_eth_rx_distribution());
  }
  if (from._internal_rx_mac_control_frames() != 0) {
    _internal_set_rx_mac_control_frames(from._internal_rx_mac_control_frames());
  }
  if (from._internal_rx_mac_pause_frames() != 0) {
    _internal_set_rx_mac_pause_frames(from._internal_rx_mac_pause_frames());
  }
  if (from._internal_rx_oversize_frames() != 0) {
    _internal_set_rx_oversize_frames(from._internal_rx_oversize_frames());
  }
  if (from._internal_rx_undersize_frames() != 0) {
    _internal_set_rx_undersize_frames(from._internal_rx_undersize_frames());
  }
  if (from._internal_rx_jabber_frames() != 0) {
    _internal_set_rx_jabber_frames(from._internal_rx_jabber_frames());
  }
  if (from._internal_rx_fragment_frames() != 0) {
    _internal_set_rx_fragment_frames(from._internal_rx_fragment_frames());
  }
  if (from._internal_rx_ieee8021q_frames() != 0) {
    _internal_set_rx_ieee8021q_frames(from._internal_rx_ieee8021q_frames());
  }
  if (from._internal_rx_crc_errors() != 0) {
    _internal_set_rx_crc_errors(from._internal_rx_crc_errors());
  }
  if (from._internal_rx_block_errors() != 0) {
    _internal_set_rx_block_errors(from._internal_rx_block_errors());
  }
  if (from._internal_rx_carrier_errors() != 0) {
    _internal_set_rx_carrier_errors(from._internal_rx_carrier_errors());
  }
  if (from._internal_rx_interrupted_tx() != 0) {
    _internal_set_rx_interrupted_tx(from._internal_rx_interrupted_tx());
  }
  if (from._internal_rx_late_collision() != 0) {
    _internal_set_rx_late_collision(from._internal_rx_late_collision());
  }
  if (from._internal_rx_mac_errors_rx() != 0) {
    _internal_set_rx_mac_errors_rx(from._internal_rx_mac_errors_rx());
  }
  if (from._internal_rx_single_collision() != 0) {
    _internal_set_rx_single_collision(from._internal_rx_single_collision());
  }
  if (from._internal_rx_symbol_error() != 0) {
    _internal_set_rx_symbol_error(from._internal_rx_symbol_error());
  }
  if (from._internal_rx_maxsize_exceeded() != 0) {
    _internal_set_rx_maxsize_exceeded(from._internal_rx_maxsize_exceeded());
  }
  if (from._internal_out_mac_control_frames() != 0) {
    _internal_set_out_mac_control_frames(from._internal_out_mac_control_frames());
  }
  if (from._internal_out_mac_pause_frames() != 0) {
    _internal_set_out_mac_pause_frames(from._internal_out_mac_pause_frames());
  }
  if (from._internal_out_ieee8021q_frames() != 0) {
    _internal_set_out_ieee8021q_frames(from._internal_out_ieee8021q_frames());
  }
  if (from._internal_out_mac_errors_tx() != 0) {
    _internal_set_out_mac_errors_tx(from._internal_out_mac_errors_tx());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EthernetCounters::CopyFrom(const EthernetCounters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.EthernetCounters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthernetCounters::IsInitialized() const {
  return true;
}

void EthernetCounters::InternalSwap(EthernetCounters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EthernetCounters, out_mac_errors_tx_)
      + sizeof(EthernetCounters::out_mac_errors_tx_)
      - PROTOBUF_FIELD_OFFSET(EthernetCounters, eth_rx_distribution_)>(
          reinterpret_cast<char*>(&eth_rx_distribution_),
          reinterpret_cast<char*>(&other->eth_rx_distribution_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EthernetCounters::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fethernet_2eproto_getter, &descriptor_table_openconfig_5fethernet_2eproto_once,
      file_level_metadata_openconfig_5fethernet_2eproto[2]);
}

// ===================================================================

class EthernetState::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::EthernetCounters& counters(const EthernetState* msg);
};

const ::opi_api::network::v1alpha1::EthernetCounters&
EthernetState::_Internal::counters(const EthernetState* msg) {
  return *msg->counters_;
}
EthernetState::EthernetState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.EthernetState)
}
EthernetState::EthernetState(const EthernetState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac_address().empty()) {
    mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mac_address(), 
      GetArenaForAllocation());
  }
  hw_mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hw_mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hw_mac_address().empty()) {
    hw_mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hw_mac_address(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_counters()) {
    counters_ = new ::opi_api::network::v1alpha1::EthernetCounters(*from.counters_);
  } else {
    counters_ = nullptr;
  }
  ::memcpy(&auto_negotiate_, &from.auto_negotiate_,
    static_cast<size_t>(reinterpret_cast<char*>(&negotiated_port_speed_) -
    reinterpret_cast<char*>(&auto_negotiate_)) + sizeof(negotiated_port_speed_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.EthernetState)
}

inline void EthernetState::SharedCtor() {
mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hw_mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hw_mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&counters_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&negotiated_port_speed_) -
    reinterpret_cast<char*>(&counters_)) + sizeof(negotiated_port_speed_));
}

EthernetState::~EthernetState() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.EthernetState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EthernetState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  mac_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hw_mac_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete counters_;
}

void EthernetState::ArenaDtor(void* object) {
  EthernetState* _this = reinterpret_cast< EthernetState* >(object);
  (void)_this;
}
void EthernetState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EthernetState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EthernetState::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.EthernetState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mac_address_.ClearToEmpty();
  hw_mac_address_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && counters_ != nullptr) {
    delete counters_;
  }
  counters_ = nullptr;
  ::memset(&auto_negotiate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&negotiated_port_speed_) -
      reinterpret_cast<char*>(&auto_negotiate_)) + sizeof(negotiated_port_speed_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EthernetState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string mac_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.network.v1alpha1.EthernetState.mac_address"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool auto_negotiate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          auto_negotiate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool standalone_link_training = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          standalone_link_training_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthDuplexMode duplex_mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_duplex_mode(static_cast<::opi_api::network::v1alpha1::EthDuplexMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthPortSpeed port_speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_port_speed(static_cast<::opi_api::network::v1alpha1::EthPortSpeed>(val));
        } else
          goto handle_unusual;
        continue;
      // bool enable_flow_control = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          enable_flow_control_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthFecMode fec_mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_fec_mode(static_cast<::opi_api::network::v1alpha1::EthFecMode>(val));
        } else
          goto handle_unusual;
        continue;
      // string hw_mac_address = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_hw_mac_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.network.v1alpha1.EthernetState.hw_mac_address"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthDuplexMode negotiated_duplex_mode = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_negotiated_duplex_mode(static_cast<::opi_api::network::v1alpha1::EthDuplexMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthPortSpeed negotiated_port_speed = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_negotiated_port_speed(static_cast<::opi_api::network::v1alpha1::EthPortSpeed>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthernetCounters counters = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_counters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EthernetState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.EthernetState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string mac_address = 1;
  if (!this->_internal_mac_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac_address().data(), static_cast<int>(this->_internal_mac_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.v1alpha1.EthernetState.mac_address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mac_address(), target);
  }

  // bool auto_negotiate = 2;
  if (this->_internal_auto_negotiate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_auto_negotiate(), target);
  }

  // bool standalone_link_training = 3;
  if (this->_internal_standalone_link_training() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_standalone_link_training(), target);
  }

  // .opi_api.network.v1alpha1.EthDuplexMode duplex_mode = 4;
  if (this->_internal_duplex_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_duplex_mode(), target);
  }

  // .opi_api.network.v1alpha1.EthPortSpeed port_speed = 5;
  if (this->_internal_port_speed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_port_speed(), target);
  }

  // bool enable_flow_control = 6;
  if (this->_internal_enable_flow_control() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_enable_flow_control(), target);
  }

  // .opi_api.network.v1alpha1.EthFecMode fec_mode = 7;
  if (this->_internal_fec_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_fec_mode(), target);
  }

  // string hw_mac_address = 8;
  if (!this->_internal_hw_mac_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hw_mac_address().data(), static_cast<int>(this->_internal_hw_mac_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.v1alpha1.EthernetState.hw_mac_address");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_hw_mac_address(), target);
  }

  // .opi_api.network.v1alpha1.EthDuplexMode negotiated_duplex_mode = 9;
  if (this->_internal_negotiated_duplex_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_negotiated_duplex_mode(), target);
  }

  // .opi_api.network.v1alpha1.EthPortSpeed negotiated_port_speed = 10;
  if (this->_internal_negotiated_port_speed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_negotiated_port_speed(), target);
  }

  // .opi_api.network.v1alpha1.EthernetCounters counters = 11;
  if (this->_internal_has_counters()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::counters(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.EthernetState)
  return target;
}

size_t EthernetState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.EthernetState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mac_address = 1;
  if (!this->_internal_mac_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac_address());
  }

  // string hw_mac_address = 8;
  if (!this->_internal_hw_mac_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hw_mac_address());
  }

  // .opi_api.network.v1alpha1.EthernetCounters counters = 11;
  if (this->_internal_has_counters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *counters_);
  }

  // bool auto_negotiate = 2;
  if (this->_internal_auto_negotiate() != 0) {
    total_size += 1 + 1;
  }

  // bool standalone_link_training = 3;
  if (this->_internal_standalone_link_training() != 0) {
    total_size += 1 + 1;
  }

  // bool enable_flow_control = 6;
  if (this->_internal_enable_flow_control() != 0) {
    total_size += 1 + 1;
  }

  // .opi_api.network.v1alpha1.EthDuplexMode duplex_mode = 4;
  if (this->_internal_duplex_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_duplex_mode());
  }

  // .opi_api.network.v1alpha1.EthPortSpeed port_speed = 5;
  if (this->_internal_port_speed() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_port_speed());
  }

  // .opi_api.network.v1alpha1.EthFecMode fec_mode = 7;
  if (this->_internal_fec_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_fec_mode());
  }

  // .opi_api.network.v1alpha1.EthDuplexMode negotiated_duplex_mode = 9;
  if (this->_internal_negotiated_duplex_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_negotiated_duplex_mode());
  }

  // .opi_api.network.v1alpha1.EthPortSpeed negotiated_port_speed = 10;
  if (this->_internal_negotiated_port_speed() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_negotiated_port_speed());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EthernetState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EthernetState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EthernetState::GetClassData() const { return &_class_data_; }

void EthernetState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EthernetState *>(to)->MergeFrom(
      static_cast<const EthernetState &>(from));
}


void EthernetState::MergeFrom(const EthernetState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.EthernetState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mac_address().empty()) {
    _internal_set_mac_address(from._internal_mac_address());
  }
  if (!from._internal_hw_mac_address().empty()) {
    _internal_set_hw_mac_address(from._internal_hw_mac_address());
  }
  if (from._internal_has_counters()) {
    _internal_mutable_counters()->::opi_api::network::v1alpha1::EthernetCounters::MergeFrom(from._internal_counters());
  }
  if (from._internal_auto_negotiate() != 0) {
    _internal_set_auto_negotiate(from._internal_auto_negotiate());
  }
  if (from._internal_standalone_link_training() != 0) {
    _internal_set_standalone_link_training(from._internal_standalone_link_training());
  }
  if (from._internal_enable_flow_control() != 0) {
    _internal_set_enable_flow_control(from._internal_enable_flow_control());
  }
  if (from._internal_duplex_mode() != 0) {
    _internal_set_duplex_mode(from._internal_duplex_mode());
  }
  if (from._internal_port_speed() != 0) {
    _internal_set_port_speed(from._internal_port_speed());
  }
  if (from._internal_fec_mode() != 0) {
    _internal_set_fec_mode(from._internal_fec_mode());
  }
  if (from._internal_negotiated_duplex_mode() != 0) {
    _internal_set_negotiated_duplex_mode(from._internal_negotiated_duplex_mode());
  }
  if (from._internal_negotiated_port_speed() != 0) {
    _internal_set_negotiated_port_speed(from._internal_negotiated_port_speed());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EthernetState::CopyFrom(const EthernetState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.EthernetState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthernetState::IsInitialized() const {
  return true;
}

void EthernetState::InternalSwap(EthernetState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mac_address_, lhs_arena,
      &other->mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hw_mac_address_, lhs_arena,
      &other->hw_mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EthernetState, negotiated_port_speed_)
      + sizeof(EthernetState::negotiated_port_speed_)
      - PROTOBUF_FIELD_OFFSET(EthernetState, counters_)>(
          reinterpret_cast<char*>(&counters_),
          reinterpret_cast<char*>(&other->counters_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EthernetState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fethernet_2eproto_getter, &descriptor_table_openconfig_5fethernet_2eproto_once,
      file_level_metadata_openconfig_5fethernet_2eproto[3]);
}

// ===================================================================

class EthernetIf::_Internal {
 public:
  static const ::opi_api::network::v1alpha1::EthernetConfig& config(const EthernetIf* msg);
  static const ::opi_api::network::v1alpha1::EthernetState& state(const EthernetIf* msg);
  static const ::opi_api::network::v1alpha1::VlanSwitchedIf& switched_vlan(const EthernetIf* msg);
};

const ::opi_api::network::v1alpha1::EthernetConfig&
EthernetIf::_Internal::config(const EthernetIf* msg) {
  return *msg->config_;
}
const ::opi_api::network::v1alpha1::EthernetState&
EthernetIf::_Internal::state(const EthernetIf* msg) {
  return *msg->state_;
}
const ::opi_api::network::v1alpha1::VlanSwitchedIf&
EthernetIf::_Internal::switched_vlan(const EthernetIf* msg) {
  return *msg->switched_vlan_;
}
void EthernetIf::clear_switched_vlan() {
  if (GetArenaForAllocation() == nullptr && switched_vlan_ != nullptr) {
    delete switched_vlan_;
  }
  switched_vlan_ = nullptr;
}
EthernetIf::EthernetIf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.network.v1alpha1.EthernetIf)
}
EthernetIf::EthernetIf(const EthernetIf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::opi_api::network::v1alpha1::EthernetConfig(*from.config_);
  } else {
    config_ = nullptr;
  }
  if (from._internal_has_state()) {
    state_ = new ::opi_api::network::v1alpha1::EthernetState(*from.state_);
  } else {
    state_ = nullptr;
  }
  if (from._internal_has_switched_vlan()) {
    switched_vlan_ = new ::opi_api::network::v1alpha1::VlanSwitchedIf(*from.switched_vlan_);
  } else {
    switched_vlan_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.v1alpha1.EthernetIf)
}

inline void EthernetIf::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&switched_vlan_) -
    reinterpret_cast<char*>(&config_)) + sizeof(switched_vlan_));
}

EthernetIf::~EthernetIf() {
  // @@protoc_insertion_point(destructor:opi_api.network.v1alpha1.EthernetIf)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EthernetIf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
  if (this != internal_default_instance()) delete state_;
  if (this != internal_default_instance()) delete switched_vlan_;
}

void EthernetIf::ArenaDtor(void* object) {
  EthernetIf* _this = reinterpret_cast< EthernetIf* >(object);
  (void)_this;
}
void EthernetIf::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EthernetIf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EthernetIf::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.v1alpha1.EthernetIf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
  if (GetArenaForAllocation() == nullptr && switched_vlan_ != nullptr) {
    delete switched_vlan_;
  }
  switched_vlan_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EthernetIf::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.v1alpha1.EthernetConfig config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.EthernetState state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.v1alpha1.VlanSwitchedIf switched_vlan = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_switched_vlan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EthernetIf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.v1alpha1.EthernetIf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.EthernetConfig config = 1;
  if (this->_internal_has_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::config(this), target, stream);
  }

  // .opi_api.network.v1alpha1.EthernetState state = 2;
  if (this->_internal_has_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::state(this), target, stream);
  }

  // .opi_api.network.v1alpha1.VlanSwitchedIf switched_vlan = 3;
  if (this->_internal_has_switched_vlan()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::switched_vlan(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.v1alpha1.EthernetIf)
  return target;
}

size_t EthernetIf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.v1alpha1.EthernetIf)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.v1alpha1.EthernetConfig config = 1;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }

  // .opi_api.network.v1alpha1.EthernetState state = 2;
  if (this->_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *state_);
  }

  // .opi_api.network.v1alpha1.VlanSwitchedIf switched_vlan = 3;
  if (this->_internal_has_switched_vlan()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *switched_vlan_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EthernetIf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EthernetIf::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EthernetIf::GetClassData() const { return &_class_data_; }

void EthernetIf::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EthernetIf *>(to)->MergeFrom(
      static_cast<const EthernetIf &>(from));
}


void EthernetIf::MergeFrom(const EthernetIf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.v1alpha1.EthernetIf)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _internal_mutable_config()->::opi_api::network::v1alpha1::EthernetConfig::MergeFrom(from._internal_config());
  }
  if (from._internal_has_state()) {
    _internal_mutable_state()->::opi_api::network::v1alpha1::EthernetState::MergeFrom(from._internal_state());
  }
  if (from._internal_has_switched_vlan()) {
    _internal_mutable_switched_vlan()->::opi_api::network::v1alpha1::VlanSwitchedIf::MergeFrom(from._internal_switched_vlan());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EthernetIf::CopyFrom(const EthernetIf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.v1alpha1.EthernetIf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthernetIf::IsInitialized() const {
  return true;
}

void EthernetIf::InternalSwap(EthernetIf* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EthernetIf, switched_vlan_)
      + sizeof(EthernetIf::switched_vlan_)
      - PROTOBUF_FIELD_OFFSET(EthernetIf, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EthernetIf::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_openconfig_5fethernet_2eproto_getter, &descriptor_table_openconfig_5fethernet_2eproto_once,
      file_level_metadata_openconfig_5fethernet_2eproto[4]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::EthernetConfig* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::EthernetConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::EthernetConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::EthernetInDistribution* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::EthernetInDistribution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::EthernetInDistribution >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::EthernetCounters* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::EthernetCounters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::EthernetCounters >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::EthernetState* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::EthernetState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::EthernetState >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::v1alpha1::EthernetIf* Arena::CreateMaybeMessage< ::opi_api::network::v1alpha1::EthernetIf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::v1alpha1::EthernetIf >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
