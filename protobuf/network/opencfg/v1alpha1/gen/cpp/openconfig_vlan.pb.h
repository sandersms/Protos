// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openconfig_vlan.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openconfig_5fvlan_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openconfig_5fvlan_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openconfig_5fvlan_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openconfig_5fvlan_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openconfig_5fvlan_2eproto;
namespace opi_api {
namespace network {
namespace v1alpha1 {
class SwitchedVlanSetting;
struct SwitchedVlanSettingDefaultTypeInternal;
extern SwitchedVlanSettingDefaultTypeInternal _SwitchedVlanSetting_default_instance_;
class VlanIf;
struct VlanIfDefaultTypeInternal;
extern VlanIfDefaultTypeInternal _VlanIf_default_instance_;
class VlanIf_VlanEgressMapping;
struct VlanIf_VlanEgressMappingDefaultTypeInternal;
extern VlanIf_VlanEgressMappingDefaultTypeInternal _VlanIf_VlanEgressMapping_default_instance_;
class VlanIf_VlanIngressMapping;
struct VlanIf_VlanIngressMappingDefaultTypeInternal;
extern VlanIf_VlanIngressMappingDefaultTypeInternal _VlanIf_VlanIngressMapping_default_instance_;
class VlanIf_VlanMatch;
struct VlanIf_VlanMatchDefaultTypeInternal;
extern VlanIf_VlanMatchDefaultTypeInternal _VlanIf_VlanMatch_default_instance_;
class VlanIf_VlanMatch_SingleTagged;
struct VlanIf_VlanMatch_SingleTaggedDefaultTypeInternal;
extern VlanIf_VlanMatch_SingleTaggedDefaultTypeInternal _VlanIf_VlanMatch_SingleTagged_default_instance_;
class VlanIf_VlanMatch_SingleTaggedList;
struct VlanIf_VlanMatch_SingleTaggedListDefaultTypeInternal;
extern VlanIf_VlanMatch_SingleTaggedListDefaultTypeInternal _VlanIf_VlanMatch_SingleTaggedList_default_instance_;
class VlanIf_VlanMatch_SingleTaggedList_TagListConfig;
struct VlanIf_VlanMatch_SingleTaggedList_TagListConfigDefaultTypeInternal;
extern VlanIf_VlanMatch_SingleTaggedList_TagListConfigDefaultTypeInternal _VlanIf_VlanMatch_SingleTaggedList_TagListConfig_default_instance_;
class VlanIf_VlanMatch_SingleTaggedList_TagListStatus;
struct VlanIf_VlanMatch_SingleTaggedList_TagListStatusDefaultTypeInternal;
extern VlanIf_VlanMatch_SingleTaggedList_TagListStatusDefaultTypeInternal _VlanIf_VlanMatch_SingleTaggedList_TagListStatus_default_instance_;
class VlanIf_VlanMatch_SingleTagged_SingleTagConfig;
struct VlanIf_VlanMatch_SingleTagged_SingleTagConfigDefaultTypeInternal;
extern VlanIf_VlanMatch_SingleTagged_SingleTagConfigDefaultTypeInternal _VlanIf_VlanMatch_SingleTagged_SingleTagConfig_default_instance_;
class VlanIf_VlanMatch_SingleTagged_SingleTagState;
struct VlanIf_VlanMatch_SingleTagged_SingleTagStateDefaultTypeInternal;
extern VlanIf_VlanMatch_SingleTagged_SingleTagStateDefaultTypeInternal _VlanIf_VlanMatch_SingleTagged_SingleTagState_default_instance_;
class VlanIngressEgressSetting;
struct VlanIngressEgressSettingDefaultTypeInternal;
extern VlanIngressEgressSettingDefaultTypeInternal _VlanIngressEgressSetting_default_instance_;
class VlanSwitchedIf;
struct VlanSwitchedIfDefaultTypeInternal;
extern VlanSwitchedIfDefaultTypeInternal _VlanSwitchedIf_default_instance_;
}  // namespace v1alpha1
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::network::v1alpha1::SwitchedVlanSetting* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::SwitchedVlanSetting>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanMatch* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanIngressEgressSetting* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIngressEgressSetting>(Arena*);
template<> ::opi_api::network::v1alpha1::VlanSwitchedIf* Arena::CreateMaybeMessage<::opi_api::network::v1alpha1::VlanSwitchedIf>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace network {
namespace v1alpha1 {

enum TpidTypes : int {
  TPID_TYPES_UNSPECIFIED = 0,
  TPID_TYPES_0X8100 = 1,
  TPID_TYPES_0X88A8 = 2,
  TPID_TYPES_0X9100 = 3,
  TPID_TYPES_0X9200 = 4,
  TPID_TYPES_ANY = 5,
  TpidTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TpidTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TpidTypes_IsValid(int value);
constexpr TpidTypes TpidTypes_MIN = TPID_TYPES_UNSPECIFIED;
constexpr TpidTypes TpidTypes_MAX = TPID_TYPES_ANY;
constexpr int TpidTypes_ARRAYSIZE = TpidTypes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TpidTypes_descriptor();
template<typename T>
inline const std::string& TpidTypes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TpidTypes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TpidTypes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TpidTypes_descriptor(), enum_t_value);
}
inline bool TpidTypes_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TpidTypes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TpidTypes>(
    TpidTypes_descriptor(), name, value);
}
enum VlanStackAction : int {
  VLAN_STACK_ACTION_UNSPECIFIED = 0,
  VLAN_STACK_ACTION_PUSH = 1,
  VLAN_STACK_ACTION_POP = 2,
  VLAN_STACK_ACTION_SWAP = 3,
  VlanStackAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VlanStackAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VlanStackAction_IsValid(int value);
constexpr VlanStackAction VlanStackAction_MIN = VLAN_STACK_ACTION_UNSPECIFIED;
constexpr VlanStackAction VlanStackAction_MAX = VLAN_STACK_ACTION_SWAP;
constexpr int VlanStackAction_ARRAYSIZE = VlanStackAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VlanStackAction_descriptor();
template<typename T>
inline const std::string& VlanStackAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VlanStackAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VlanStackAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VlanStackAction_descriptor(), enum_t_value);
}
inline bool VlanStackAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VlanStackAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VlanStackAction>(
    VlanStackAction_descriptor(), name, value);
}
enum VlanIfMode : int {
  VLAN_IF_MODE_UNSPECIFIED = 0,
  VLAN_IF_MODE_ACCESS = 1,
  VLAN_IF_MODE_TRUNK = 2,
  VlanIfMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VlanIfMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VlanIfMode_IsValid(int value);
constexpr VlanIfMode VlanIfMode_MIN = VLAN_IF_MODE_UNSPECIFIED;
constexpr VlanIfMode VlanIfMode_MAX = VLAN_IF_MODE_TRUNK;
constexpr int VlanIfMode_ARRAYSIZE = VlanIfMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VlanIfMode_descriptor();
template<typename T>
inline const std::string& VlanIfMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VlanIfMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VlanIfMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VlanIfMode_descriptor(), enum_t_value);
}
inline bool VlanIfMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VlanIfMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VlanIfMode>(
    VlanIfMode_descriptor(), name, value);
}
// ===================================================================

class SwitchedVlanSetting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.SwitchedVlanSetting) */ {
 public:
  inline SwitchedVlanSetting() : SwitchedVlanSetting(nullptr) {}
  ~SwitchedVlanSetting() override;
  explicit constexpr SwitchedVlanSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchedVlanSetting(const SwitchedVlanSetting& from);
  SwitchedVlanSetting(SwitchedVlanSetting&& from) noexcept
    : SwitchedVlanSetting() {
    *this = ::std::move(from);
  }

  inline SwitchedVlanSetting& operator=(const SwitchedVlanSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchedVlanSetting& operator=(SwitchedVlanSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchedVlanSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchedVlanSetting* internal_default_instance() {
    return reinterpret_cast<const SwitchedVlanSetting*>(
               &_SwitchedVlanSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SwitchedVlanSetting& a, SwitchedVlanSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchedVlanSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchedVlanSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchedVlanSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchedVlanSetting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchedVlanSetting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SwitchedVlanSetting& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchedVlanSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.SwitchedVlanSetting";
  }
  protected:
  explicit SwitchedVlanSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrunkVlansFieldNumber = 4,
    kVlanInterfaceModeFieldNumber = 1,
    kNativeVlanFieldNumber = 2,
    kAccessVlanFieldNumber = 3,
  };
  // string trunk_vlans = 4;
  void clear_trunk_vlans();
  const std::string& trunk_vlans() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trunk_vlans(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trunk_vlans();
  PROTOBUF_NODISCARD std::string* release_trunk_vlans();
  void set_allocated_trunk_vlans(std::string* trunk_vlans);
  private:
  const std::string& _internal_trunk_vlans() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trunk_vlans(const std::string& value);
  std::string* _internal_mutable_trunk_vlans();
  public:

  // .opi_api.network.v1alpha1.VlanIfMode vlan_interface_mode = 1;
  void clear_vlan_interface_mode();
  ::opi_api::network::v1alpha1::VlanIfMode vlan_interface_mode() const;
  void set_vlan_interface_mode(::opi_api::network::v1alpha1::VlanIfMode value);
  private:
  ::opi_api::network::v1alpha1::VlanIfMode _internal_vlan_interface_mode() const;
  void _internal_set_vlan_interface_mode(::opi_api::network::v1alpha1::VlanIfMode value);
  public:

  // uint32 native_vlan = 2;
  void clear_native_vlan();
  uint32_t native_vlan() const;
  void set_native_vlan(uint32_t value);
  private:
  uint32_t _internal_native_vlan() const;
  void _internal_set_native_vlan(uint32_t value);
  public:

  // uint32 access_vlan = 3;
  void clear_access_vlan();
  uint32_t access_vlan() const;
  void set_access_vlan(uint32_t value);
  private:
  uint32_t _internal_access_vlan() const;
  void _internal_set_access_vlan(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.SwitchedVlanSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trunk_vlans_;
  int vlan_interface_mode_;
  uint32_t native_vlan_;
  uint32_t access_vlan_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanSwitchedIf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanSwitchedIf) */ {
 public:
  inline VlanSwitchedIf() : VlanSwitchedIf(nullptr) {}
  ~VlanSwitchedIf() override;
  explicit constexpr VlanSwitchedIf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanSwitchedIf(const VlanSwitchedIf& from);
  VlanSwitchedIf(VlanSwitchedIf&& from) noexcept
    : VlanSwitchedIf() {
    *this = ::std::move(from);
  }

  inline VlanSwitchedIf& operator=(const VlanSwitchedIf& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanSwitchedIf& operator=(VlanSwitchedIf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanSwitchedIf& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanSwitchedIf* internal_default_instance() {
    return reinterpret_cast<const VlanSwitchedIf*>(
               &_VlanSwitchedIf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VlanSwitchedIf& a, VlanSwitchedIf& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanSwitchedIf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanSwitchedIf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanSwitchedIf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanSwitchedIf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanSwitchedIf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanSwitchedIf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanSwitchedIf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanSwitchedIf";
  }
  protected:
  explicit VlanSwitchedIf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .opi_api.network.v1alpha1.SwitchedVlanSetting config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::opi_api::network::v1alpha1::SwitchedVlanSetting& config() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::SwitchedVlanSetting* release_config();
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* mutable_config();
  void set_allocated_config(::opi_api::network::v1alpha1::SwitchedVlanSetting* config);
  private:
  const ::opi_api::network::v1alpha1::SwitchedVlanSetting& _internal_config() const;
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::opi_api::network::v1alpha1::SwitchedVlanSetting* config);
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* unsafe_arena_release_config();

  // .opi_api.network.v1alpha1.SwitchedVlanSetting state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::opi_api::network::v1alpha1::SwitchedVlanSetting& state() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::SwitchedVlanSetting* release_state();
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* mutable_state();
  void set_allocated_state(::opi_api::network::v1alpha1::SwitchedVlanSetting* state);
  private:
  const ::opi_api::network::v1alpha1::SwitchedVlanSetting& _internal_state() const;
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::opi_api::network::v1alpha1::SwitchedVlanSetting* state);
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanSwitchedIf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* config_;
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIngressEgressSetting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIngressEgressSetting) */ {
 public:
  inline VlanIngressEgressSetting() : VlanIngressEgressSetting(nullptr) {}
  ~VlanIngressEgressSetting() override;
  explicit constexpr VlanIngressEgressSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIngressEgressSetting(const VlanIngressEgressSetting& from);
  VlanIngressEgressSetting(VlanIngressEgressSetting&& from) noexcept
    : VlanIngressEgressSetting() {
    *this = ::std::move(from);
  }

  inline VlanIngressEgressSetting& operator=(const VlanIngressEgressSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIngressEgressSetting& operator=(VlanIngressEgressSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIngressEgressSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIngressEgressSetting* internal_default_instance() {
    return reinterpret_cast<const VlanIngressEgressSetting*>(
               &_VlanIngressEgressSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VlanIngressEgressSetting& a, VlanIngressEgressSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIngressEgressSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIngressEgressSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIngressEgressSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIngressEgressSetting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIngressEgressSetting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIngressEgressSetting& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIngressEgressSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIngressEgressSetting";
  }
  protected:
  explicit VlanIngressEgressSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVlanstackactionFieldNumber = 1,
    kVlanIdFieldNumber = 2,
    kTpidFieldNumber = 3,
  };
  // .opi_api.network.v1alpha1.VlanStackAction vlanstackaction = 1;
  void clear_vlanstackaction();
  ::opi_api::network::v1alpha1::VlanStackAction vlanstackaction() const;
  void set_vlanstackaction(::opi_api::network::v1alpha1::VlanStackAction value);
  private:
  ::opi_api::network::v1alpha1::VlanStackAction _internal_vlanstackaction() const;
  void _internal_set_vlanstackaction(::opi_api::network::v1alpha1::VlanStackAction value);
  public:

  // uint32 vlan_id = 2;
  void clear_vlan_id();
  uint32_t vlan_id() const;
  void set_vlan_id(uint32_t value);
  private:
  uint32_t _internal_vlan_id() const;
  void _internal_set_vlan_id(uint32_t value);
  public:

  // .opi_api.network.v1alpha1.TpidTypes tpid = 3;
  void clear_tpid();
  ::opi_api::network::v1alpha1::TpidTypes tpid() const;
  void set_tpid(::opi_api::network::v1alpha1::TpidTypes value);
  private:
  ::opi_api::network::v1alpha1::TpidTypes _internal_tpid() const;
  void _internal_set_tpid(::opi_api::network::v1alpha1::TpidTypes value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIngressEgressSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int vlanstackaction_;
  uint32_t vlan_id_;
  int tpid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanMatch_SingleTagged_SingleTagConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig) */ {
 public:
  inline VlanIf_VlanMatch_SingleTagged_SingleTagConfig() : VlanIf_VlanMatch_SingleTagged_SingleTagConfig(nullptr) {}
  ~VlanIf_VlanMatch_SingleTagged_SingleTagConfig() override;
  explicit constexpr VlanIf_VlanMatch_SingleTagged_SingleTagConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanMatch_SingleTagged_SingleTagConfig(const VlanIf_VlanMatch_SingleTagged_SingleTagConfig& from);
  VlanIf_VlanMatch_SingleTagged_SingleTagConfig(VlanIf_VlanMatch_SingleTagged_SingleTagConfig&& from) noexcept
    : VlanIf_VlanMatch_SingleTagged_SingleTagConfig() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanMatch_SingleTagged_SingleTagConfig& operator=(const VlanIf_VlanMatch_SingleTagged_SingleTagConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanMatch_SingleTagged_SingleTagConfig& operator=(VlanIf_VlanMatch_SingleTagged_SingleTagConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanMatch_SingleTagged_SingleTagConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanMatch_SingleTagged_SingleTagConfig* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanMatch_SingleTagged_SingleTagConfig*>(
               &_VlanIf_VlanMatch_SingleTagged_SingleTagConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VlanIf_VlanMatch_SingleTagged_SingleTagConfig& a, VlanIf_VlanMatch_SingleTagged_SingleTagConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanMatch_SingleTagged_SingleTagConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanMatch_SingleTagged_SingleTagConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanMatch_SingleTagged_SingleTagConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanMatch_SingleTagged_SingleTagConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanMatch_SingleTagged_SingleTagConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanMatch_SingleTagged_SingleTagConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanMatch_SingleTagged_SingleTagConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig";
  }
  protected:
  explicit VlanIf_VlanMatch_SingleTagged_SingleTagConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVlanIdFieldNumber = 1,
  };
  // uint32 vlan_id = 1;
  void clear_vlan_id();
  uint32_t vlan_id() const;
  void set_vlan_id(uint32_t value);
  private:
  uint32_t _internal_vlan_id() const;
  void _internal_set_vlan_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t vlan_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanMatch_SingleTagged_SingleTagState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState) */ {
 public:
  inline VlanIf_VlanMatch_SingleTagged_SingleTagState() : VlanIf_VlanMatch_SingleTagged_SingleTagState(nullptr) {}
  ~VlanIf_VlanMatch_SingleTagged_SingleTagState() override;
  explicit constexpr VlanIf_VlanMatch_SingleTagged_SingleTagState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanMatch_SingleTagged_SingleTagState(const VlanIf_VlanMatch_SingleTagged_SingleTagState& from);
  VlanIf_VlanMatch_SingleTagged_SingleTagState(VlanIf_VlanMatch_SingleTagged_SingleTagState&& from) noexcept
    : VlanIf_VlanMatch_SingleTagged_SingleTagState() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanMatch_SingleTagged_SingleTagState& operator=(const VlanIf_VlanMatch_SingleTagged_SingleTagState& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanMatch_SingleTagged_SingleTagState& operator=(VlanIf_VlanMatch_SingleTagged_SingleTagState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanMatch_SingleTagged_SingleTagState& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanMatch_SingleTagged_SingleTagState* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanMatch_SingleTagged_SingleTagState*>(
               &_VlanIf_VlanMatch_SingleTagged_SingleTagState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VlanIf_VlanMatch_SingleTagged_SingleTagState& a, VlanIf_VlanMatch_SingleTagged_SingleTagState& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanMatch_SingleTagged_SingleTagState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanMatch_SingleTagged_SingleTagState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanMatch_SingleTagged_SingleTagState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanMatch_SingleTagged_SingleTagState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanMatch_SingleTagged_SingleTagState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanMatch_SingleTagged_SingleTagState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanMatch_SingleTagged_SingleTagState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState";
  }
  protected:
  explicit VlanIf_VlanMatch_SingleTagged_SingleTagState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVlanIdFieldNumber = 1,
  };
  // uint32 vlan_id = 1;
  void clear_vlan_id();
  uint32_t vlan_id() const;
  void set_vlan_id(uint32_t value);
  private:
  uint32_t _internal_vlan_id() const;
  void _internal_set_vlan_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t vlan_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanMatch_SingleTagged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged) */ {
 public:
  inline VlanIf_VlanMatch_SingleTagged() : VlanIf_VlanMatch_SingleTagged(nullptr) {}
  ~VlanIf_VlanMatch_SingleTagged() override;
  explicit constexpr VlanIf_VlanMatch_SingleTagged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanMatch_SingleTagged(const VlanIf_VlanMatch_SingleTagged& from);
  VlanIf_VlanMatch_SingleTagged(VlanIf_VlanMatch_SingleTagged&& from) noexcept
    : VlanIf_VlanMatch_SingleTagged() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanMatch_SingleTagged& operator=(const VlanIf_VlanMatch_SingleTagged& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanMatch_SingleTagged& operator=(VlanIf_VlanMatch_SingleTagged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanMatch_SingleTagged& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanMatch_SingleTagged* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanMatch_SingleTagged*>(
               &_VlanIf_VlanMatch_SingleTagged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VlanIf_VlanMatch_SingleTagged& a, VlanIf_VlanMatch_SingleTagged& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanMatch_SingleTagged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanMatch_SingleTagged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanMatch_SingleTagged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanMatch_SingleTagged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanMatch_SingleTagged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanMatch_SingleTagged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanMatch_SingleTagged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged";
  }
  protected:
  explicit VlanIf_VlanMatch_SingleTagged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VlanIf_VlanMatch_SingleTagged_SingleTagConfig SingleTagConfig;
  typedef VlanIf_VlanMatch_SingleTagged_SingleTagState SingleTagState;

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig& config() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* release_config();
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* mutable_config();
  void set_allocated_config(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* config);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig& _internal_config() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* config);
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* unsafe_arena_release_config();

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState& state() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* release_state();
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* mutable_state();
  void set_allocated_state(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* state);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState& _internal_state() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* state);
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* config_;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanMatch_SingleTaggedList_TagListConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig) */ {
 public:
  inline VlanIf_VlanMatch_SingleTaggedList_TagListConfig() : VlanIf_VlanMatch_SingleTaggedList_TagListConfig(nullptr) {}
  ~VlanIf_VlanMatch_SingleTaggedList_TagListConfig() override;
  explicit constexpr VlanIf_VlanMatch_SingleTaggedList_TagListConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanMatch_SingleTaggedList_TagListConfig(const VlanIf_VlanMatch_SingleTaggedList_TagListConfig& from);
  VlanIf_VlanMatch_SingleTaggedList_TagListConfig(VlanIf_VlanMatch_SingleTaggedList_TagListConfig&& from) noexcept
    : VlanIf_VlanMatch_SingleTaggedList_TagListConfig() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanMatch_SingleTaggedList_TagListConfig& operator=(const VlanIf_VlanMatch_SingleTaggedList_TagListConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanMatch_SingleTaggedList_TagListConfig& operator=(VlanIf_VlanMatch_SingleTaggedList_TagListConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanMatch_SingleTaggedList_TagListConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanMatch_SingleTaggedList_TagListConfig* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanMatch_SingleTaggedList_TagListConfig*>(
               &_VlanIf_VlanMatch_SingleTaggedList_TagListConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VlanIf_VlanMatch_SingleTaggedList_TagListConfig& a, VlanIf_VlanMatch_SingleTaggedList_TagListConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanMatch_SingleTaggedList_TagListConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanMatch_SingleTaggedList_TagListConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanMatch_SingleTaggedList_TagListConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanMatch_SingleTaggedList_TagListConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanMatch_SingleTaggedList_TagListConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanMatch_SingleTaggedList_TagListConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanMatch_SingleTaggedList_TagListConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig";
  }
  protected:
  explicit VlanIf_VlanMatch_SingleTaggedList_TagListConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVlanIdFieldNumber = 1,
  };
  // repeated uint32 vlan_id = 1;
  int vlan_id_size() const;
  private:
  int _internal_vlan_id_size() const;
  public:
  void clear_vlan_id();
  private:
  uint32_t _internal_vlan_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_vlan_id() const;
  void _internal_add_vlan_id(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_vlan_id();
  public:
  uint32_t vlan_id(int index) const;
  void set_vlan_id(int index, uint32_t value);
  void add_vlan_id(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      vlan_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_vlan_id();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > vlan_id_;
  mutable std::atomic<int> _vlan_id_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanMatch_SingleTaggedList_TagListStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus) */ {
 public:
  inline VlanIf_VlanMatch_SingleTaggedList_TagListStatus() : VlanIf_VlanMatch_SingleTaggedList_TagListStatus(nullptr) {}
  ~VlanIf_VlanMatch_SingleTaggedList_TagListStatus() override;
  explicit constexpr VlanIf_VlanMatch_SingleTaggedList_TagListStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanMatch_SingleTaggedList_TagListStatus(const VlanIf_VlanMatch_SingleTaggedList_TagListStatus& from);
  VlanIf_VlanMatch_SingleTaggedList_TagListStatus(VlanIf_VlanMatch_SingleTaggedList_TagListStatus&& from) noexcept
    : VlanIf_VlanMatch_SingleTaggedList_TagListStatus() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanMatch_SingleTaggedList_TagListStatus& operator=(const VlanIf_VlanMatch_SingleTaggedList_TagListStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanMatch_SingleTaggedList_TagListStatus& operator=(VlanIf_VlanMatch_SingleTaggedList_TagListStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanMatch_SingleTaggedList_TagListStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanMatch_SingleTaggedList_TagListStatus* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanMatch_SingleTaggedList_TagListStatus*>(
               &_VlanIf_VlanMatch_SingleTaggedList_TagListStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VlanIf_VlanMatch_SingleTaggedList_TagListStatus& a, VlanIf_VlanMatch_SingleTaggedList_TagListStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanMatch_SingleTaggedList_TagListStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanMatch_SingleTaggedList_TagListStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanMatch_SingleTaggedList_TagListStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanMatch_SingleTaggedList_TagListStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanMatch_SingleTaggedList_TagListStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanMatch_SingleTaggedList_TagListStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanMatch_SingleTaggedList_TagListStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus";
  }
  protected:
  explicit VlanIf_VlanMatch_SingleTaggedList_TagListStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVlanidFieldNumber = 1,
  };
  // repeated uint32 vlanid = 1;
  int vlanid_size() const;
  private:
  int _internal_vlanid_size() const;
  public:
  void clear_vlanid();
  private:
  uint32_t _internal_vlanid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_vlanid() const;
  void _internal_add_vlanid(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_vlanid();
  public:
  uint32_t vlanid(int index) const;
  void set_vlanid(int index, uint32_t value);
  void add_vlanid(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      vlanid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_vlanid();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > vlanid_;
  mutable std::atomic<int> _vlanid_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanMatch_SingleTaggedList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList) */ {
 public:
  inline VlanIf_VlanMatch_SingleTaggedList() : VlanIf_VlanMatch_SingleTaggedList(nullptr) {}
  ~VlanIf_VlanMatch_SingleTaggedList() override;
  explicit constexpr VlanIf_VlanMatch_SingleTaggedList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanMatch_SingleTaggedList(const VlanIf_VlanMatch_SingleTaggedList& from);
  VlanIf_VlanMatch_SingleTaggedList(VlanIf_VlanMatch_SingleTaggedList&& from) noexcept
    : VlanIf_VlanMatch_SingleTaggedList() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanMatch_SingleTaggedList& operator=(const VlanIf_VlanMatch_SingleTaggedList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanMatch_SingleTaggedList& operator=(VlanIf_VlanMatch_SingleTaggedList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanMatch_SingleTaggedList& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanMatch_SingleTaggedList* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanMatch_SingleTaggedList*>(
               &_VlanIf_VlanMatch_SingleTaggedList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VlanIf_VlanMatch_SingleTaggedList& a, VlanIf_VlanMatch_SingleTaggedList& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanMatch_SingleTaggedList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanMatch_SingleTaggedList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanMatch_SingleTaggedList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanMatch_SingleTaggedList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanMatch_SingleTaggedList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanMatch_SingleTaggedList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanMatch_SingleTaggedList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList";
  }
  protected:
  explicit VlanIf_VlanMatch_SingleTaggedList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VlanIf_VlanMatch_SingleTaggedList_TagListConfig TagListConfig;
  typedef VlanIf_VlanMatch_SingleTaggedList_TagListStatus TagListStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig& config() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* release_config();
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* mutable_config();
  void set_allocated_config(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* config);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig& _internal_config() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* config);
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* unsafe_arena_release_config();

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* release_status();
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* mutable_status();
  void set_allocated_status(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* status);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus& _internal_status() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* status);
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* config_;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanMatch) */ {
 public:
  inline VlanIf_VlanMatch() : VlanIf_VlanMatch(nullptr) {}
  ~VlanIf_VlanMatch() override;
  explicit constexpr VlanIf_VlanMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanMatch(const VlanIf_VlanMatch& from);
  VlanIf_VlanMatch(VlanIf_VlanMatch&& from) noexcept
    : VlanIf_VlanMatch() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanMatch& operator=(const VlanIf_VlanMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanMatch& operator=(VlanIf_VlanMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanMatch* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanMatch*>(
               &_VlanIf_VlanMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VlanIf_VlanMatch& a, VlanIf_VlanMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanMatch";
  }
  protected:
  explicit VlanIf_VlanMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VlanIf_VlanMatch_SingleTagged SingleTagged;
  typedef VlanIf_VlanMatch_SingleTaggedList SingleTaggedList;

  // accessors -------------------------------------------------------

  enum : int {
    kSingletaggedFieldNumber = 1,
    kSingletaggedlistFieldNumber = 2,
  };
  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged singletagged = 1;
  bool has_singletagged() const;
  private:
  bool _internal_has_singletagged() const;
  public:
  void clear_singletagged();
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged& singletagged() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* release_singletagged();
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* mutable_singletagged();
  void set_allocated_singletagged(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* singletagged);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged& _internal_singletagged() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* _internal_mutable_singletagged();
  public:
  void unsafe_arena_set_allocated_singletagged(
      ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* singletagged);
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* unsafe_arena_release_singletagged();

  // .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList singletaggedlist = 2;
  bool has_singletaggedlist() const;
  private:
  bool _internal_has_singletaggedlist() const;
  public:
  void clear_singletaggedlist();
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList& singletaggedlist() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* release_singletaggedlist();
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* mutable_singletaggedlist();
  void set_allocated_singletaggedlist(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* singletaggedlist);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList& _internal_singletaggedlist() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* _internal_mutable_singletaggedlist();
  public:
  void unsafe_arena_set_allocated_singletaggedlist(
      ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* singletaggedlist);
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* unsafe_arena_release_singletaggedlist();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* singletagged_;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* singletaggedlist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanIngressMapping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping) */ {
 public:
  inline VlanIf_VlanIngressMapping() : VlanIf_VlanIngressMapping(nullptr) {}
  ~VlanIf_VlanIngressMapping() override;
  explicit constexpr VlanIf_VlanIngressMapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanIngressMapping(const VlanIf_VlanIngressMapping& from);
  VlanIf_VlanIngressMapping(VlanIf_VlanIngressMapping&& from) noexcept
    : VlanIf_VlanIngressMapping() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanIngressMapping& operator=(const VlanIf_VlanIngressMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanIngressMapping& operator=(VlanIf_VlanIngressMapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanIngressMapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanIngressMapping* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanIngressMapping*>(
               &_VlanIf_VlanIngressMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VlanIf_VlanIngressMapping& a, VlanIf_VlanIngressMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanIngressMapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanIngressMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanIngressMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanIngressMapping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanIngressMapping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanIngressMapping& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanIngressMapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanIngressMapping";
  }
  protected:
  explicit VlanIf_VlanIngressMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& config() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIngressEgressSetting* release_config();
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* mutable_config();
  void set_allocated_config(::opi_api::network::v1alpha1::VlanIngressEgressSetting* config);
  private:
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& _internal_config() const;
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::opi_api::network::v1alpha1::VlanIngressEgressSetting* config);
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* unsafe_arena_release_config();

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& state() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIngressEgressSetting* release_state();
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* mutable_state();
  void set_allocated_state(::opi_api::network::v1alpha1::VlanIngressEgressSetting* state);
  private:
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& _internal_state() const;
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::opi_api::network::v1alpha1::VlanIngressEgressSetting* state);
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* config_;
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf_VlanEgressMapping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping) */ {
 public:
  inline VlanIf_VlanEgressMapping() : VlanIf_VlanEgressMapping(nullptr) {}
  ~VlanIf_VlanEgressMapping() override;
  explicit constexpr VlanIf_VlanEgressMapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf_VlanEgressMapping(const VlanIf_VlanEgressMapping& from);
  VlanIf_VlanEgressMapping(VlanIf_VlanEgressMapping&& from) noexcept
    : VlanIf_VlanEgressMapping() {
    *this = ::std::move(from);
  }

  inline VlanIf_VlanEgressMapping& operator=(const VlanIf_VlanEgressMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf_VlanEgressMapping& operator=(VlanIf_VlanEgressMapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf_VlanEgressMapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf_VlanEgressMapping* internal_default_instance() {
    return reinterpret_cast<const VlanIf_VlanEgressMapping*>(
               &_VlanIf_VlanEgressMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VlanIf_VlanEgressMapping& a, VlanIf_VlanEgressMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf_VlanEgressMapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf_VlanEgressMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf_VlanEgressMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf_VlanEgressMapping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf_VlanEgressMapping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf_VlanEgressMapping& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf_VlanEgressMapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf.VlanEgressMapping";
  }
  protected:
  explicit VlanIf_VlanEgressMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& config() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIngressEgressSetting* release_config();
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* mutable_config();
  void set_allocated_config(::opi_api::network::v1alpha1::VlanIngressEgressSetting* config);
  private:
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& _internal_config() const;
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::opi_api::network::v1alpha1::VlanIngressEgressSetting* config);
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* unsafe_arena_release_config();

  // .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& state() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIngressEgressSetting* release_state();
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* mutable_state();
  void set_allocated_state(::opi_api::network::v1alpha1::VlanIngressEgressSetting* state);
  private:
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& _internal_state() const;
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::opi_api::network::v1alpha1::VlanIngressEgressSetting* state);
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* config_;
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// -------------------------------------------------------------------

class VlanIf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.v1alpha1.VlanIf) */ {
 public:
  inline VlanIf() : VlanIf(nullptr) {}
  ~VlanIf() override;
  explicit constexpr VlanIf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VlanIf(const VlanIf& from);
  VlanIf(VlanIf&& from) noexcept
    : VlanIf() {
    *this = ::std::move(from);
  }

  inline VlanIf& operator=(const VlanIf& from) {
    CopyFrom(from);
    return *this;
  }
  inline VlanIf& operator=(VlanIf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VlanIf& default_instance() {
    return *internal_default_instance();
  }
  static inline const VlanIf* internal_default_instance() {
    return reinterpret_cast<const VlanIf*>(
               &_VlanIf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VlanIf& a, VlanIf& b) {
    a.Swap(&b);
  }
  inline void Swap(VlanIf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VlanIf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VlanIf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VlanIf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VlanIf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VlanIf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VlanIf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.v1alpha1.VlanIf";
  }
  protected:
  explicit VlanIf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VlanIf_VlanMatch VlanMatch;
  typedef VlanIf_VlanIngressMapping VlanIngressMapping;
  typedef VlanIf_VlanEgressMapping VlanEgressMapping;

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFieldNumber = 1,
    kIngressmappingFieldNumber = 2,
    kEgressmappingFieldNumber = 3,
  };
  // .opi_api.network.v1alpha1.VlanIf.VlanMatch match = 1;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch& match() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanMatch* release_match();
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch* mutable_match();
  void set_allocated_match(::opi_api::network::v1alpha1::VlanIf_VlanMatch* match);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch& _internal_match() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch* _internal_mutable_match();
  public:
  void unsafe_arena_set_allocated_match(
      ::opi_api::network::v1alpha1::VlanIf_VlanMatch* match);
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch* unsafe_arena_release_match();

  // .opi_api.network.v1alpha1.VlanIf.VlanIngressMapping ingressmapping = 2;
  bool has_ingressmapping() const;
  private:
  bool _internal_has_ingressmapping() const;
  public:
  void clear_ingressmapping();
  const ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping& ingressmapping() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* release_ingressmapping();
  ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* mutable_ingressmapping();
  void set_allocated_ingressmapping(::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* ingressmapping);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping& _internal_ingressmapping() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* _internal_mutable_ingressmapping();
  public:
  void unsafe_arena_set_allocated_ingressmapping(
      ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* ingressmapping);
  ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* unsafe_arena_release_ingressmapping();

  // .opi_api.network.v1alpha1.VlanIf.VlanEgressMapping egressmapping = 3;
  bool has_egressmapping() const;
  private:
  bool _internal_has_egressmapping() const;
  public:
  void clear_egressmapping();
  const ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping& egressmapping() const;
  PROTOBUF_NODISCARD ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* release_egressmapping();
  ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* mutable_egressmapping();
  void set_allocated_egressmapping(::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* egressmapping);
  private:
  const ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping& _internal_egressmapping() const;
  ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* _internal_mutable_egressmapping();
  public:
  void unsafe_arena_set_allocated_egressmapping(
      ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* egressmapping);
  ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* unsafe_arena_release_egressmapping();

  // @@protoc_insertion_point(class_scope:opi_api.network.v1alpha1.VlanIf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch* match_;
  ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* ingressmapping_;
  ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* egressmapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openconfig_5fvlan_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SwitchedVlanSetting

// .opi_api.network.v1alpha1.VlanIfMode vlan_interface_mode = 1;
inline void SwitchedVlanSetting::clear_vlan_interface_mode() {
  vlan_interface_mode_ = 0;
}
inline ::opi_api::network::v1alpha1::VlanIfMode SwitchedVlanSetting::_internal_vlan_interface_mode() const {
  return static_cast< ::opi_api::network::v1alpha1::VlanIfMode >(vlan_interface_mode_);
}
inline ::opi_api::network::v1alpha1::VlanIfMode SwitchedVlanSetting::vlan_interface_mode() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.SwitchedVlanSetting.vlan_interface_mode)
  return _internal_vlan_interface_mode();
}
inline void SwitchedVlanSetting::_internal_set_vlan_interface_mode(::opi_api::network::v1alpha1::VlanIfMode value) {
  
  vlan_interface_mode_ = value;
}
inline void SwitchedVlanSetting::set_vlan_interface_mode(::opi_api::network::v1alpha1::VlanIfMode value) {
  _internal_set_vlan_interface_mode(value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.SwitchedVlanSetting.vlan_interface_mode)
}

// uint32 native_vlan = 2;
inline void SwitchedVlanSetting::clear_native_vlan() {
  native_vlan_ = 0u;
}
inline uint32_t SwitchedVlanSetting::_internal_native_vlan() const {
  return native_vlan_;
}
inline uint32_t SwitchedVlanSetting::native_vlan() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.SwitchedVlanSetting.native_vlan)
  return _internal_native_vlan();
}
inline void SwitchedVlanSetting::_internal_set_native_vlan(uint32_t value) {
  
  native_vlan_ = value;
}
inline void SwitchedVlanSetting::set_native_vlan(uint32_t value) {
  _internal_set_native_vlan(value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.SwitchedVlanSetting.native_vlan)
}

// uint32 access_vlan = 3;
inline void SwitchedVlanSetting::clear_access_vlan() {
  access_vlan_ = 0u;
}
inline uint32_t SwitchedVlanSetting::_internal_access_vlan() const {
  return access_vlan_;
}
inline uint32_t SwitchedVlanSetting::access_vlan() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.SwitchedVlanSetting.access_vlan)
  return _internal_access_vlan();
}
inline void SwitchedVlanSetting::_internal_set_access_vlan(uint32_t value) {
  
  access_vlan_ = value;
}
inline void SwitchedVlanSetting::set_access_vlan(uint32_t value) {
  _internal_set_access_vlan(value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.SwitchedVlanSetting.access_vlan)
}

// string trunk_vlans = 4;
inline void SwitchedVlanSetting::clear_trunk_vlans() {
  trunk_vlans_.ClearToEmpty();
}
inline const std::string& SwitchedVlanSetting::trunk_vlans() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.SwitchedVlanSetting.trunk_vlans)
  return _internal_trunk_vlans();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SwitchedVlanSetting::set_trunk_vlans(ArgT0&& arg0, ArgT... args) {
 
 trunk_vlans_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.SwitchedVlanSetting.trunk_vlans)
}
inline std::string* SwitchedVlanSetting::mutable_trunk_vlans() {
  std::string* _s = _internal_mutable_trunk_vlans();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.SwitchedVlanSetting.trunk_vlans)
  return _s;
}
inline const std::string& SwitchedVlanSetting::_internal_trunk_vlans() const {
  return trunk_vlans_.Get();
}
inline void SwitchedVlanSetting::_internal_set_trunk_vlans(const std::string& value) {
  
  trunk_vlans_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SwitchedVlanSetting::_internal_mutable_trunk_vlans() {
  
  return trunk_vlans_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SwitchedVlanSetting::release_trunk_vlans() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.SwitchedVlanSetting.trunk_vlans)
  return trunk_vlans_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SwitchedVlanSetting::set_allocated_trunk_vlans(std::string* trunk_vlans) {
  if (trunk_vlans != nullptr) {
    
  } else {
    
  }
  trunk_vlans_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trunk_vlans,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trunk_vlans_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trunk_vlans_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.SwitchedVlanSetting.trunk_vlans)
}

// -------------------------------------------------------------------

// VlanSwitchedIf

// .opi_api.network.v1alpha1.SwitchedVlanSetting config = 1;
inline bool VlanSwitchedIf::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool VlanSwitchedIf::has_config() const {
  return _internal_has_config();
}
inline void VlanSwitchedIf::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::SwitchedVlanSetting& VlanSwitchedIf::_internal_config() const {
  const ::opi_api::network::v1alpha1::SwitchedVlanSetting* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::SwitchedVlanSetting&>(
      ::opi_api::network::v1alpha1::_SwitchedVlanSetting_default_instance_);
}
inline const ::opi_api::network::v1alpha1::SwitchedVlanSetting& VlanSwitchedIf::config() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanSwitchedIf.config)
  return _internal_config();
}
inline void VlanSwitchedIf::unsafe_arena_set_allocated_config(
    ::opi_api::network::v1alpha1::SwitchedVlanSetting* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanSwitchedIf.config)
}
inline ::opi_api::network::v1alpha1::SwitchedVlanSetting* VlanSwitchedIf::release_config() {
  
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::SwitchedVlanSetting* VlanSwitchedIf::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanSwitchedIf.config)
  
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::SwitchedVlanSetting* VlanSwitchedIf::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::SwitchedVlanSetting>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::opi_api::network::v1alpha1::SwitchedVlanSetting* VlanSwitchedIf::mutable_config() {
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanSwitchedIf.config)
  return _msg;
}
inline void VlanSwitchedIf::set_allocated_config(::opi_api::network::v1alpha1::SwitchedVlanSetting* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::SwitchedVlanSetting>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanSwitchedIf.config)
}

// .opi_api.network.v1alpha1.SwitchedVlanSetting state = 2;
inline bool VlanSwitchedIf::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool VlanSwitchedIf::has_state() const {
  return _internal_has_state();
}
inline void VlanSwitchedIf::clear_state() {
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::SwitchedVlanSetting& VlanSwitchedIf::_internal_state() const {
  const ::opi_api::network::v1alpha1::SwitchedVlanSetting* p = state_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::SwitchedVlanSetting&>(
      ::opi_api::network::v1alpha1::_SwitchedVlanSetting_default_instance_);
}
inline const ::opi_api::network::v1alpha1::SwitchedVlanSetting& VlanSwitchedIf::state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanSwitchedIf.state)
  return _internal_state();
}
inline void VlanSwitchedIf::unsafe_arena_set_allocated_state(
    ::opi_api::network::v1alpha1::SwitchedVlanSetting* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanSwitchedIf.state)
}
inline ::opi_api::network::v1alpha1::SwitchedVlanSetting* VlanSwitchedIf::release_state() {
  
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* temp = state_;
  state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::SwitchedVlanSetting* VlanSwitchedIf::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanSwitchedIf.state)
  
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::SwitchedVlanSetting* VlanSwitchedIf::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::SwitchedVlanSetting>(GetArenaForAllocation());
    state_ = p;
  }
  return state_;
}
inline ::opi_api::network::v1alpha1::SwitchedVlanSetting* VlanSwitchedIf::mutable_state() {
  ::opi_api::network::v1alpha1::SwitchedVlanSetting* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanSwitchedIf.state)
  return _msg;
}
inline void VlanSwitchedIf::set_allocated_state(::opi_api::network::v1alpha1::SwitchedVlanSetting* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::SwitchedVlanSetting>::GetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanSwitchedIf.state)
}

// -------------------------------------------------------------------

// VlanIngressEgressSetting

// .opi_api.network.v1alpha1.VlanStackAction vlanstackaction = 1;
inline void VlanIngressEgressSetting::clear_vlanstackaction() {
  vlanstackaction_ = 0;
}
inline ::opi_api::network::v1alpha1::VlanStackAction VlanIngressEgressSetting::_internal_vlanstackaction() const {
  return static_cast< ::opi_api::network::v1alpha1::VlanStackAction >(vlanstackaction_);
}
inline ::opi_api::network::v1alpha1::VlanStackAction VlanIngressEgressSetting::vlanstackaction() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIngressEgressSetting.vlanstackaction)
  return _internal_vlanstackaction();
}
inline void VlanIngressEgressSetting::_internal_set_vlanstackaction(::opi_api::network::v1alpha1::VlanStackAction value) {
  
  vlanstackaction_ = value;
}
inline void VlanIngressEgressSetting::set_vlanstackaction(::opi_api::network::v1alpha1::VlanStackAction value) {
  _internal_set_vlanstackaction(value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.VlanIngressEgressSetting.vlanstackaction)
}

// uint32 vlan_id = 2;
inline void VlanIngressEgressSetting::clear_vlan_id() {
  vlan_id_ = 0u;
}
inline uint32_t VlanIngressEgressSetting::_internal_vlan_id() const {
  return vlan_id_;
}
inline uint32_t VlanIngressEgressSetting::vlan_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIngressEgressSetting.vlan_id)
  return _internal_vlan_id();
}
inline void VlanIngressEgressSetting::_internal_set_vlan_id(uint32_t value) {
  
  vlan_id_ = value;
}
inline void VlanIngressEgressSetting::set_vlan_id(uint32_t value) {
  _internal_set_vlan_id(value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.VlanIngressEgressSetting.vlan_id)
}

// .opi_api.network.v1alpha1.TpidTypes tpid = 3;
inline void VlanIngressEgressSetting::clear_tpid() {
  tpid_ = 0;
}
inline ::opi_api::network::v1alpha1::TpidTypes VlanIngressEgressSetting::_internal_tpid() const {
  return static_cast< ::opi_api::network::v1alpha1::TpidTypes >(tpid_);
}
inline ::opi_api::network::v1alpha1::TpidTypes VlanIngressEgressSetting::tpid() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIngressEgressSetting.tpid)
  return _internal_tpid();
}
inline void VlanIngressEgressSetting::_internal_set_tpid(::opi_api::network::v1alpha1::TpidTypes value) {
  
  tpid_ = value;
}
inline void VlanIngressEgressSetting::set_tpid(::opi_api::network::v1alpha1::TpidTypes value) {
  _internal_set_tpid(value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.VlanIngressEgressSetting.tpid)
}

// -------------------------------------------------------------------

// VlanIf_VlanMatch_SingleTagged_SingleTagConfig

// uint32 vlan_id = 1;
inline void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::clear_vlan_id() {
  vlan_id_ = 0u;
}
inline uint32_t VlanIf_VlanMatch_SingleTagged_SingleTagConfig::_internal_vlan_id() const {
  return vlan_id_;
}
inline uint32_t VlanIf_VlanMatch_SingleTagged_SingleTagConfig::vlan_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig.vlan_id)
  return _internal_vlan_id();
}
inline void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::_internal_set_vlan_id(uint32_t value) {
  
  vlan_id_ = value;
}
inline void VlanIf_VlanMatch_SingleTagged_SingleTagConfig::set_vlan_id(uint32_t value) {
  _internal_set_vlan_id(value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig.vlan_id)
}

// -------------------------------------------------------------------

// VlanIf_VlanMatch_SingleTagged_SingleTagState

// uint32 vlan_id = 1;
inline void VlanIf_VlanMatch_SingleTagged_SingleTagState::clear_vlan_id() {
  vlan_id_ = 0u;
}
inline uint32_t VlanIf_VlanMatch_SingleTagged_SingleTagState::_internal_vlan_id() const {
  return vlan_id_;
}
inline uint32_t VlanIf_VlanMatch_SingleTagged_SingleTagState::vlan_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState.vlan_id)
  return _internal_vlan_id();
}
inline void VlanIf_VlanMatch_SingleTagged_SingleTagState::_internal_set_vlan_id(uint32_t value) {
  
  vlan_id_ = value;
}
inline void VlanIf_VlanMatch_SingleTagged_SingleTagState::set_vlan_id(uint32_t value) {
  _internal_set_vlan_id(value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState.vlan_id)
}

// -------------------------------------------------------------------

// VlanIf_VlanMatch_SingleTagged

// .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagConfig config = 1;
inline bool VlanIf_VlanMatch_SingleTagged::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool VlanIf_VlanMatch_SingleTagged::has_config() const {
  return _internal_has_config();
}
inline void VlanIf_VlanMatch_SingleTagged::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig& VlanIf_VlanMatch_SingleTagged::_internal_config() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTagged_SingleTagConfig_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig& VlanIf_VlanMatch_SingleTagged::config() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.config)
  return _internal_config();
}
inline void VlanIf_VlanMatch_SingleTagged::unsafe_arena_set_allocated_config(
    ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.config)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* VlanIf_VlanMatch_SingleTagged::release_config() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* VlanIf_VlanMatch_SingleTagged::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.config)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* VlanIf_VlanMatch_SingleTagged::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* VlanIf_VlanMatch_SingleTagged::mutable_config() {
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.config)
  return _msg;
}
inline void VlanIf_VlanMatch_SingleTagged::set_allocated_config(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.config)
}

// .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.SingleTagState state = 2;
inline bool VlanIf_VlanMatch_SingleTagged::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool VlanIf_VlanMatch_SingleTagged::has_state() const {
  return _internal_has_state();
}
inline void VlanIf_VlanMatch_SingleTagged::clear_state() {
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState& VlanIf_VlanMatch_SingleTagged::_internal_state() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* p = state_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTagged_SingleTagState_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState& VlanIf_VlanMatch_SingleTagged::state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.state)
  return _internal_state();
}
inline void VlanIf_VlanMatch_SingleTagged::unsafe_arena_set_allocated_state(
    ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.state)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* VlanIf_VlanMatch_SingleTagged::release_state() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* temp = state_;
  state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* VlanIf_VlanMatch_SingleTagged::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.state)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* VlanIf_VlanMatch_SingleTagged::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState>(GetArenaForAllocation());
    state_ = p;
  }
  return state_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* VlanIf_VlanMatch_SingleTagged::mutable_state() {
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.state)
  return _msg;
}
inline void VlanIf_VlanMatch_SingleTagged::set_allocated_state(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged_SingleTagState>::GetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged.state)
}

// -------------------------------------------------------------------

// VlanIf_VlanMatch_SingleTaggedList_TagListConfig

// repeated uint32 vlan_id = 1;
inline int VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_internal_vlan_id_size() const {
  return vlan_id_.size();
}
inline int VlanIf_VlanMatch_SingleTaggedList_TagListConfig::vlan_id_size() const {
  return _internal_vlan_id_size();
}
inline void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::clear_vlan_id() {
  vlan_id_.Clear();
}
inline uint32_t VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_internal_vlan_id(int index) const {
  return vlan_id_.Get(index);
}
inline uint32_t VlanIf_VlanMatch_SingleTaggedList_TagListConfig::vlan_id(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig.vlan_id)
  return _internal_vlan_id(index);
}
inline void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::set_vlan_id(int index, uint32_t value) {
  vlan_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig.vlan_id)
}
inline void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_internal_add_vlan_id(uint32_t value) {
  vlan_id_.Add(value);
}
inline void VlanIf_VlanMatch_SingleTaggedList_TagListConfig::add_vlan_id(uint32_t value) {
  _internal_add_vlan_id(value);
  // @@protoc_insertion_point(field_add:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig.vlan_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_internal_vlan_id() const {
  return vlan_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
VlanIf_VlanMatch_SingleTaggedList_TagListConfig::vlan_id() const {
  // @@protoc_insertion_point(field_list:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig.vlan_id)
  return _internal_vlan_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
VlanIf_VlanMatch_SingleTaggedList_TagListConfig::_internal_mutable_vlan_id() {
  return &vlan_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
VlanIf_VlanMatch_SingleTaggedList_TagListConfig::mutable_vlan_id() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig.vlan_id)
  return _internal_mutable_vlan_id();
}

// -------------------------------------------------------------------

// VlanIf_VlanMatch_SingleTaggedList_TagListStatus

// repeated uint32 vlanid = 1;
inline int VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_internal_vlanid_size() const {
  return vlanid_.size();
}
inline int VlanIf_VlanMatch_SingleTaggedList_TagListStatus::vlanid_size() const {
  return _internal_vlanid_size();
}
inline void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::clear_vlanid() {
  vlanid_.Clear();
}
inline uint32_t VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_internal_vlanid(int index) const {
  return vlanid_.Get(index);
}
inline uint32_t VlanIf_VlanMatch_SingleTaggedList_TagListStatus::vlanid(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus.vlanid)
  return _internal_vlanid(index);
}
inline void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::set_vlanid(int index, uint32_t value) {
  vlanid_.Set(index, value);
  // @@protoc_insertion_point(field_set:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus.vlanid)
}
inline void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_internal_add_vlanid(uint32_t value) {
  vlanid_.Add(value);
}
inline void VlanIf_VlanMatch_SingleTaggedList_TagListStatus::add_vlanid(uint32_t value) {
  _internal_add_vlanid(value);
  // @@protoc_insertion_point(field_add:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus.vlanid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_internal_vlanid() const {
  return vlanid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
VlanIf_VlanMatch_SingleTaggedList_TagListStatus::vlanid() const {
  // @@protoc_insertion_point(field_list:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus.vlanid)
  return _internal_vlanid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
VlanIf_VlanMatch_SingleTaggedList_TagListStatus::_internal_mutable_vlanid() {
  return &vlanid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
VlanIf_VlanMatch_SingleTaggedList_TagListStatus::mutable_vlanid() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus.vlanid)
  return _internal_mutable_vlanid();
}

// -------------------------------------------------------------------

// VlanIf_VlanMatch_SingleTaggedList

// .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListConfig config = 1;
inline bool VlanIf_VlanMatch_SingleTaggedList::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool VlanIf_VlanMatch_SingleTaggedList::has_config() const {
  return _internal_has_config();
}
inline void VlanIf_VlanMatch_SingleTaggedList::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig& VlanIf_VlanMatch_SingleTaggedList::_internal_config() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTaggedList_TagListConfig_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig& VlanIf_VlanMatch_SingleTaggedList::config() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.config)
  return _internal_config();
}
inline void VlanIf_VlanMatch_SingleTaggedList::unsafe_arena_set_allocated_config(
    ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.config)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* VlanIf_VlanMatch_SingleTaggedList::release_config() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* VlanIf_VlanMatch_SingleTaggedList::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.config)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* VlanIf_VlanMatch_SingleTaggedList::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* VlanIf_VlanMatch_SingleTaggedList::mutable_config() {
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.config)
  return _msg;
}
inline void VlanIf_VlanMatch_SingleTaggedList::set_allocated_config(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.config)
}

// .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.TagListStatus status = 2;
inline bool VlanIf_VlanMatch_SingleTaggedList::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool VlanIf_VlanMatch_SingleTaggedList::has_status() const {
  return _internal_has_status();
}
inline void VlanIf_VlanMatch_SingleTaggedList::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus& VlanIf_VlanMatch_SingleTaggedList::_internal_status() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTaggedList_TagListStatus_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus& VlanIf_VlanMatch_SingleTaggedList::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.status)
  return _internal_status();
}
inline void VlanIf_VlanMatch_SingleTaggedList::unsafe_arena_set_allocated_status(
    ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.status)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* VlanIf_VlanMatch_SingleTaggedList::release_status() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* VlanIf_VlanMatch_SingleTaggedList::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.status)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* VlanIf_VlanMatch_SingleTaggedList::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* VlanIf_VlanMatch_SingleTaggedList::mutable_status() {
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.status)
  return _msg;
}
inline void VlanIf_VlanMatch_SingleTaggedList::set_allocated_status(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList_TagListStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList.status)
}

// -------------------------------------------------------------------

// VlanIf_VlanMatch

// .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTagged singletagged = 1;
inline bool VlanIf_VlanMatch::_internal_has_singletagged() const {
  return this != internal_default_instance() && singletagged_ != nullptr;
}
inline bool VlanIf_VlanMatch::has_singletagged() const {
  return _internal_has_singletagged();
}
inline void VlanIf_VlanMatch::clear_singletagged() {
  if (GetArenaForAllocation() == nullptr && singletagged_ != nullptr) {
    delete singletagged_;
  }
  singletagged_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged& VlanIf_VlanMatch::_internal_singletagged() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* p = singletagged_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTagged_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged& VlanIf_VlanMatch::singletagged() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletagged)
  return _internal_singletagged();
}
inline void VlanIf_VlanMatch::unsafe_arena_set_allocated_singletagged(
    ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* singletagged) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(singletagged_);
  }
  singletagged_ = singletagged;
  if (singletagged) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletagged)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* VlanIf_VlanMatch::release_singletagged() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* temp = singletagged_;
  singletagged_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* VlanIf_VlanMatch::unsafe_arena_release_singletagged() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletagged)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* temp = singletagged_;
  singletagged_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* VlanIf_VlanMatch::_internal_mutable_singletagged() {
  
  if (singletagged_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged>(GetArenaForAllocation());
    singletagged_ = p;
  }
  return singletagged_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* VlanIf_VlanMatch::mutable_singletagged() {
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* _msg = _internal_mutable_singletagged();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletagged)
  return _msg;
}
inline void VlanIf_VlanMatch::set_allocated_singletagged(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged* singletagged) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete singletagged_;
  }
  if (singletagged) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTagged>::GetOwningArena(singletagged);
    if (message_arena != submessage_arena) {
      singletagged = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, singletagged, submessage_arena);
    }
    
  } else {
    
  }
  singletagged_ = singletagged;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletagged)
}

// .opi_api.network.v1alpha1.VlanIf.VlanMatch.SingleTaggedList singletaggedlist = 2;
inline bool VlanIf_VlanMatch::_internal_has_singletaggedlist() const {
  return this != internal_default_instance() && singletaggedlist_ != nullptr;
}
inline bool VlanIf_VlanMatch::has_singletaggedlist() const {
  return _internal_has_singletaggedlist();
}
inline void VlanIf_VlanMatch::clear_singletaggedlist() {
  if (GetArenaForAllocation() == nullptr && singletaggedlist_ != nullptr) {
    delete singletaggedlist_;
  }
  singletaggedlist_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList& VlanIf_VlanMatch::_internal_singletaggedlist() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* p = singletaggedlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanMatch_SingleTaggedList_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList& VlanIf_VlanMatch::singletaggedlist() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletaggedlist)
  return _internal_singletaggedlist();
}
inline void VlanIf_VlanMatch::unsafe_arena_set_allocated_singletaggedlist(
    ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* singletaggedlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(singletaggedlist_);
  }
  singletaggedlist_ = singletaggedlist;
  if (singletaggedlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletaggedlist)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* VlanIf_VlanMatch::release_singletaggedlist() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* temp = singletaggedlist_;
  singletaggedlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* VlanIf_VlanMatch::unsafe_arena_release_singletaggedlist() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletaggedlist)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* temp = singletaggedlist_;
  singletaggedlist_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* VlanIf_VlanMatch::_internal_mutable_singletaggedlist() {
  
  if (singletaggedlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList>(GetArenaForAllocation());
    singletaggedlist_ = p;
  }
  return singletaggedlist_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* VlanIf_VlanMatch::mutable_singletaggedlist() {
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* _msg = _internal_mutable_singletaggedlist();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletaggedlist)
  return _msg;
}
inline void VlanIf_VlanMatch::set_allocated_singletaggedlist(::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList* singletaggedlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete singletaggedlist_;
  }
  if (singletaggedlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanMatch_SingleTaggedList>::GetOwningArena(singletaggedlist);
    if (message_arena != submessage_arena) {
      singletaggedlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, singletaggedlist, submessage_arena);
    }
    
  } else {
    
  }
  singletaggedlist_ = singletaggedlist;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanMatch.singletaggedlist)
}

// -------------------------------------------------------------------

// VlanIf_VlanIngressMapping

// .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
inline bool VlanIf_VlanIngressMapping::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool VlanIf_VlanIngressMapping::has_config() const {
  return _internal_has_config();
}
inline void VlanIf_VlanIngressMapping::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& VlanIf_VlanIngressMapping::_internal_config() const {
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIngressEgressSetting&>(
      ::opi_api::network::v1alpha1::_VlanIngressEgressSetting_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& VlanIf_VlanIngressMapping::config() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.config)
  return _internal_config();
}
inline void VlanIf_VlanIngressMapping::unsafe_arena_set_allocated_config(
    ::opi_api::network::v1alpha1::VlanIngressEgressSetting* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.config)
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanIngressMapping::release_config() {
  
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanIngressMapping::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.config)
  
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanIngressMapping::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIngressEgressSetting>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanIngressMapping::mutable_config() {
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.config)
  return _msg;
}
inline void VlanIf_VlanIngressMapping::set_allocated_config(::opi_api::network::v1alpha1::VlanIngressEgressSetting* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIngressEgressSetting>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.config)
}

// .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
inline bool VlanIf_VlanIngressMapping::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool VlanIf_VlanIngressMapping::has_state() const {
  return _internal_has_state();
}
inline void VlanIf_VlanIngressMapping::clear_state() {
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& VlanIf_VlanIngressMapping::_internal_state() const {
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting* p = state_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIngressEgressSetting&>(
      ::opi_api::network::v1alpha1::_VlanIngressEgressSetting_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& VlanIf_VlanIngressMapping::state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.state)
  return _internal_state();
}
inline void VlanIf_VlanIngressMapping::unsafe_arena_set_allocated_state(
    ::opi_api::network::v1alpha1::VlanIngressEgressSetting* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.state)
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanIngressMapping::release_state() {
  
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* temp = state_;
  state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanIngressMapping::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.state)
  
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanIngressMapping::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIngressEgressSetting>(GetArenaForAllocation());
    state_ = p;
  }
  return state_;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanIngressMapping::mutable_state() {
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.state)
  return _msg;
}
inline void VlanIf_VlanIngressMapping::set_allocated_state(::opi_api::network::v1alpha1::VlanIngressEgressSetting* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIngressEgressSetting>::GetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanIngressMapping.state)
}

// -------------------------------------------------------------------

// VlanIf_VlanEgressMapping

// .opi_api.network.v1alpha1.VlanIngressEgressSetting config = 1;
inline bool VlanIf_VlanEgressMapping::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool VlanIf_VlanEgressMapping::has_config() const {
  return _internal_has_config();
}
inline void VlanIf_VlanEgressMapping::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& VlanIf_VlanEgressMapping::_internal_config() const {
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIngressEgressSetting&>(
      ::opi_api::network::v1alpha1::_VlanIngressEgressSetting_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& VlanIf_VlanEgressMapping::config() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.config)
  return _internal_config();
}
inline void VlanIf_VlanEgressMapping::unsafe_arena_set_allocated_config(
    ::opi_api::network::v1alpha1::VlanIngressEgressSetting* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.config)
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanEgressMapping::release_config() {
  
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanEgressMapping::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.config)
  
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanEgressMapping::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIngressEgressSetting>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanEgressMapping::mutable_config() {
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.config)
  return _msg;
}
inline void VlanIf_VlanEgressMapping::set_allocated_config(::opi_api::network::v1alpha1::VlanIngressEgressSetting* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIngressEgressSetting>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.config)
}

// .opi_api.network.v1alpha1.VlanIngressEgressSetting state = 2;
inline bool VlanIf_VlanEgressMapping::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool VlanIf_VlanEgressMapping::has_state() const {
  return _internal_has_state();
}
inline void VlanIf_VlanEgressMapping::clear_state() {
  if (GetArenaForAllocation() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& VlanIf_VlanEgressMapping::_internal_state() const {
  const ::opi_api::network::v1alpha1::VlanIngressEgressSetting* p = state_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIngressEgressSetting&>(
      ::opi_api::network::v1alpha1::_VlanIngressEgressSetting_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIngressEgressSetting& VlanIf_VlanEgressMapping::state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.state)
  return _internal_state();
}
inline void VlanIf_VlanEgressMapping::unsafe_arena_set_allocated_state(
    ::opi_api::network::v1alpha1::VlanIngressEgressSetting* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.state)
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanEgressMapping::release_state() {
  
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* temp = state_;
  state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanEgressMapping::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.state)
  
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanEgressMapping::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIngressEgressSetting>(GetArenaForAllocation());
    state_ = p;
  }
  return state_;
}
inline ::opi_api::network::v1alpha1::VlanIngressEgressSetting* VlanIf_VlanEgressMapping::mutable_state() {
  ::opi_api::network::v1alpha1::VlanIngressEgressSetting* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.state)
  return _msg;
}
inline void VlanIf_VlanEgressMapping::set_allocated_state(::opi_api::network::v1alpha1::VlanIngressEgressSetting* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIngressEgressSetting>::GetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.VlanEgressMapping.state)
}

// -------------------------------------------------------------------

// VlanIf

// .opi_api.network.v1alpha1.VlanIf.VlanMatch match = 1;
inline bool VlanIf::_internal_has_match() const {
  return this != internal_default_instance() && match_ != nullptr;
}
inline bool VlanIf::has_match() const {
  return _internal_has_match();
}
inline void VlanIf::clear_match() {
  if (GetArenaForAllocation() == nullptr && match_ != nullptr) {
    delete match_;
  }
  match_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch& VlanIf::_internal_match() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanMatch* p = match_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanMatch&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanMatch_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanMatch& VlanIf::match() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.match)
  return _internal_match();
}
inline void VlanIf::unsafe_arena_set_allocated_match(
    ::opi_api::network::v1alpha1::VlanIf_VlanMatch* match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_);
  }
  match_ = match;
  if (match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.match)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch* VlanIf::release_match() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch* temp = match_;
  match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch* VlanIf::unsafe_arena_release_match() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.match)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch* temp = match_;
  match_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch* VlanIf::_internal_mutable_match() {
  
  if (match_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanMatch>(GetArenaForAllocation());
    match_ = p;
  }
  return match_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanMatch* VlanIf::mutable_match() {
  ::opi_api::network::v1alpha1::VlanIf_VlanMatch* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.match)
  return _msg;
}
inline void VlanIf::set_allocated_match(::opi_api::network::v1alpha1::VlanIf_VlanMatch* match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_;
  }
  if (match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanMatch>::GetOwningArena(match);
    if (message_arena != submessage_arena) {
      match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    
  } else {
    
  }
  match_ = match;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.match)
}

// .opi_api.network.v1alpha1.VlanIf.VlanIngressMapping ingressmapping = 2;
inline bool VlanIf::_internal_has_ingressmapping() const {
  return this != internal_default_instance() && ingressmapping_ != nullptr;
}
inline bool VlanIf::has_ingressmapping() const {
  return _internal_has_ingressmapping();
}
inline void VlanIf::clear_ingressmapping() {
  if (GetArenaForAllocation() == nullptr && ingressmapping_ != nullptr) {
    delete ingressmapping_;
  }
  ingressmapping_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping& VlanIf::_internal_ingressmapping() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* p = ingressmapping_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanIngressMapping_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping& VlanIf::ingressmapping() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.ingressmapping)
  return _internal_ingressmapping();
}
inline void VlanIf::unsafe_arena_set_allocated_ingressmapping(
    ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* ingressmapping) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ingressmapping_);
  }
  ingressmapping_ = ingressmapping;
  if (ingressmapping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.ingressmapping)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* VlanIf::release_ingressmapping() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* temp = ingressmapping_;
  ingressmapping_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* VlanIf::unsafe_arena_release_ingressmapping() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.ingressmapping)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* temp = ingressmapping_;
  ingressmapping_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* VlanIf::_internal_mutable_ingressmapping() {
  
  if (ingressmapping_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping>(GetArenaForAllocation());
    ingressmapping_ = p;
  }
  return ingressmapping_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* VlanIf::mutable_ingressmapping() {
  ::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* _msg = _internal_mutable_ingressmapping();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.ingressmapping)
  return _msg;
}
inline void VlanIf::set_allocated_ingressmapping(::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping* ingressmapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ingressmapping_;
  }
  if (ingressmapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanIngressMapping>::GetOwningArena(ingressmapping);
    if (message_arena != submessage_arena) {
      ingressmapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ingressmapping, submessage_arena);
    }
    
  } else {
    
  }
  ingressmapping_ = ingressmapping;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.ingressmapping)
}

// .opi_api.network.v1alpha1.VlanIf.VlanEgressMapping egressmapping = 3;
inline bool VlanIf::_internal_has_egressmapping() const {
  return this != internal_default_instance() && egressmapping_ != nullptr;
}
inline bool VlanIf::has_egressmapping() const {
  return _internal_has_egressmapping();
}
inline void VlanIf::clear_egressmapping() {
  if (GetArenaForAllocation() == nullptr && egressmapping_ != nullptr) {
    delete egressmapping_;
  }
  egressmapping_ = nullptr;
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping& VlanIf::_internal_egressmapping() const {
  const ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* p = egressmapping_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping&>(
      ::opi_api::network::v1alpha1::_VlanIf_VlanEgressMapping_default_instance_);
}
inline const ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping& VlanIf::egressmapping() const {
  // @@protoc_insertion_point(field_get:opi_api.network.v1alpha1.VlanIf.egressmapping)
  return _internal_egressmapping();
}
inline void VlanIf::unsafe_arena_set_allocated_egressmapping(
    ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* egressmapping) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(egressmapping_);
  }
  egressmapping_ = egressmapping;
  if (egressmapping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.v1alpha1.VlanIf.egressmapping)
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* VlanIf::release_egressmapping() {
  
  ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* temp = egressmapping_;
  egressmapping_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* VlanIf::unsafe_arena_release_egressmapping() {
  // @@protoc_insertion_point(field_release:opi_api.network.v1alpha1.VlanIf.egressmapping)
  
  ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* temp = egressmapping_;
  egressmapping_ = nullptr;
  return temp;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* VlanIf::_internal_mutable_egressmapping() {
  
  if (egressmapping_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping>(GetArenaForAllocation());
    egressmapping_ = p;
  }
  return egressmapping_;
}
inline ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* VlanIf::mutable_egressmapping() {
  ::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* _msg = _internal_mutable_egressmapping();
  // @@protoc_insertion_point(field_mutable:opi_api.network.v1alpha1.VlanIf.egressmapping)
  return _msg;
}
inline void VlanIf::set_allocated_egressmapping(::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping* egressmapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete egressmapping_;
  }
  if (egressmapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::v1alpha1::VlanIf_VlanEgressMapping>::GetOwningArena(egressmapping);
    if (message_arena != submessage_arena) {
      egressmapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, egressmapping, submessage_arena);
    }
    
  } else {
    
  }
  egressmapping_ = egressmapping;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.v1alpha1.VlanIf.egressmapping)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace network
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::network::v1alpha1::TpidTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::v1alpha1::TpidTypes>() {
  return ::opi_api::network::v1alpha1::TpidTypes_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::v1alpha1::VlanStackAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::v1alpha1::VlanStackAction>() {
  return ::opi_api::network::v1alpha1::VlanStackAction_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::v1alpha1::VlanIfMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::v1alpha1::VlanIfMode>() {
  return ::opi_api::network::v1alpha1::VlanIfMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openconfig_5fvlan_2eproto
